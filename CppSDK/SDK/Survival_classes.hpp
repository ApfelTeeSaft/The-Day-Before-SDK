#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Survival

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "BattlEye_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Survival_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "ChaosVehicles_classes.hpp"
#include "UMG_classes.hpp"
#include "AdvancedThirdPersonCamera_structs.hpp"
#include "AdvancedThirdPersonCamera_classes.hpp"


namespace SDK
{

// Class Survival.BP_AnimUROComponent
// 0x0010 (0x00B0 - 0x00A0)
class UBP_AnimUROComponent final : public UActorComponent
{
public:
	TArray<int32>                                 M_pLOD_FrameRate;                                  // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void SetMeshCustomURO(class USkinnedMeshComponent* MeshToURO, int32 UroLevel);
	void SetMeshURO(class USkinnedMeshComponent* MeshToURO);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BP_AnimUROComponent">();
	}
	static class UBP_AnimUROComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AnimUROComponent>();
	}
};
static_assert(alignof(UBP_AnimUROComponent) == 0x000008, "Wrong alignment on UBP_AnimUROComponent");
static_assert(sizeof(UBP_AnimUROComponent) == 0x0000B0, "Wrong size on UBP_AnimUROComponent");
static_assert(offsetof(UBP_AnimUROComponent, M_pLOD_FrameRate) == 0x0000A0, "Member 'UBP_AnimUROComponent::M_pLOD_FrameRate' has a wrong offset!");

// Class Survival.ZombieCharacter
// 0x0010 (0x0640 - 0x0630)
class AZombieCharacter : public ACharacter
{
public:
	FMulticastInlineDelegateProperty_             OnSetTargetActorCPP;                               // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	EZombieAnimType                               ZombieAnimType;                                    // 0x0638(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAgressive;                                        // 0x0639(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDamaged;                                          // 0x063A(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZombieType                                   CPPZombieType;                                     // 0x063B(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAgressive();
	bool GetBackToIdle();
	EZombieType GetCPPZombieType();
	bool GetDamaged();
	EZombieAnimType GetZombieAnimType();
	void SetAgressive(bool NewValue);
	void SetBackToIdle(bool NewValue);
	void SetCPPZombieType(EZombieType NewValue);
	void SetDamaged(bool NewValue);
	void SetZombieAnimType(EZombieAnimType NewZombieAnimType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieCharacter">();
	}
	static class AZombieCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieCharacter>();
	}
};
static_assert(alignof(AZombieCharacter) == 0x000010, "Wrong alignment on AZombieCharacter");
static_assert(sizeof(AZombieCharacter) == 0x000640, "Wrong size on AZombieCharacter");
static_assert(offsetof(AZombieCharacter, OnSetTargetActorCPP) == 0x000628, "Member 'AZombieCharacter::OnSetTargetActorCPP' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, ZombieAnimType) == 0x000638, "Member 'AZombieCharacter::ZombieAnimType' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, bAgressive) == 0x000639, "Member 'AZombieCharacter::bAgressive' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, bDamaged) == 0x00063A, "Member 'AZombieCharacter::bDamaged' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, CPPZombieType) == 0x00063B, "Member 'AZombieCharacter::CPPZombieType' has a wrong offset!");

// Class Survival.AdditionalEditorFunctions
// 0x0000 (0x0028 - 0x0028)
class UAdditionalEditorFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetViewportCamera();
	static bool IsWithEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdditionalEditorFunctions">();
	}
	static class UAdditionalEditorFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdditionalEditorFunctions>();
	}
};
static_assert(alignof(UAdditionalEditorFunctions) == 0x000008, "Wrong alignment on UAdditionalEditorFunctions");
static_assert(sizeof(UAdditionalEditorFunctions) == 0x000028, "Wrong size on UAdditionalEditorFunctions");

// Class Survival.AIControllerTeam
// 0x0008 (0x03C0 - 0x03B8)
class AAIControllerTeam : public AAIController
{
public:
	struct FGenericTeamId                         TeamID;                                            // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCrowdSimulationState(class UCrowdFollowingComponent* CrowdFollowingComponent);

	void GetActorPerceptionViewpoint(struct FVector* Out_Location, struct FRotator* Out_Rotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIControllerTeam">();
	}
	static class AAIControllerTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIControllerTeam>();
	}
};
static_assert(alignof(AAIControllerTeam) == 0x000008, "Wrong alignment on AAIControllerTeam");
static_assert(sizeof(AAIControllerTeam) == 0x0003C0, "Wrong size on AAIControllerTeam");
static_assert(offsetof(AAIControllerTeam, TeamID) == 0x0003B8, "Member 'AAIControllerTeam::TeamID' has a wrong offset!");

// Class Survival.AIMoveComp
// 0x0010 (0x00B0 - 0x00A0)
class UAIMoveComp : public UActorComponent
{
public:
	bool                                          bCPPIsStopping;                                    // 0x00A0(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCPPVelocityFromAnimation;                         // 0x00A1(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CPPAnimationAngle;                                 // 0x00A4(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	Survival::EMovementType                       CPPMovementType;                                   // 0x00A8(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CPPMovementTypeRepNotify();
	float GetCPPAnimationAngle();
	bool GetCPPIsStopping();
	Survival::EMovementType GetCPPMovementType();
	bool GetCPPVelocityFromAnimation();
	float GetCPPVelocityValue();
	void OnRep_CPPMovementType();
	void SetCPPAnimationAngle(float NewValue);
	void SetCPPIsStopping(bool NewValue);
	void SetCPPMovementType(Survival::EMovementType NewValue);
	void SetCPPVelocityFromAnimation(bool NewValue);
	void SetCPPVelocityValue(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveComp">();
	}
	static class UAIMoveComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveComp>();
	}
};
static_assert(alignof(UAIMoveComp) == 0x000008, "Wrong alignment on UAIMoveComp");
static_assert(sizeof(UAIMoveComp) == 0x0000B0, "Wrong size on UAIMoveComp");
static_assert(offsetof(UAIMoveComp, bCPPIsStopping) == 0x0000A0, "Member 'UAIMoveComp::bCPPIsStopping' has a wrong offset!");
static_assert(offsetof(UAIMoveComp, bCPPVelocityFromAnimation) == 0x0000A1, "Member 'UAIMoveComp::bCPPVelocityFromAnimation' has a wrong offset!");
static_assert(offsetof(UAIMoveComp, CPPAnimationAngle) == 0x0000A4, "Member 'UAIMoveComp::CPPAnimationAngle' has a wrong offset!");
static_assert(offsetof(UAIMoveComp, CPPMovementType) == 0x0000A8, "Member 'UAIMoveComp::CPPMovementType' has a wrong offset!");

// Class Survival.AIParentPawn
// 0x0018 (0x0330 - 0x0318)
class AAIParentPawn final : public APawn
{
public:
	class UPawnMovementComponent*                 MovementComponent;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CollisionComponent;                                // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIParentPawn">();
	}
	static class AAIParentPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIParentPawn>();
	}
};
static_assert(alignof(AAIParentPawn) == 0x000008, "Wrong alignment on AAIParentPawn");
static_assert(sizeof(AAIParentPawn) == 0x000330, "Wrong size on AAIParentPawn");
static_assert(offsetof(AAIParentPawn, MovementComponent) == 0x000318, "Member 'AAIParentPawn::MovementComponent' has a wrong offset!");
static_assert(offsetof(AAIParentPawn, MeshComponent) == 0x000320, "Member 'AAIParentPawn::MeshComponent' has a wrong offset!");
static_assert(offsetof(AAIParentPawn, CollisionComponent) == 0x000328, "Member 'AAIParentPawn::CollisionComponent' has a wrong offset!");

// Class Survival.AnimationURO
// 0x0020 (0x00C0 - 0x00A0)
class UAnimationURO final : public UActorComponent
{
public:
	bool                                          InterpolateSkipFramesURO;                          // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxEvalRateForInterpolationURO;                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         baseNonRenderedUpdateRateURO;                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkipFrameRateLOD;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationURO">();
	}
	static class UAnimationURO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationURO>();
	}
};
static_assert(alignof(UAnimationURO) == 0x000008, "Wrong alignment on UAnimationURO");
static_assert(sizeof(UAnimationURO) == 0x0000C0, "Wrong size on UAnimationURO");
static_assert(offsetof(UAnimationURO, InterpolateSkipFramesURO) == 0x0000A0, "Member 'UAnimationURO::InterpolateSkipFramesURO' has a wrong offset!");
static_assert(offsetof(UAnimationURO, MaxEvalRateForInterpolationURO) == 0x0000A4, "Member 'UAnimationURO::MaxEvalRateForInterpolationURO' has a wrong offset!");
static_assert(offsetof(UAnimationURO, baseNonRenderedUpdateRateURO) == 0x0000A8, "Member 'UAnimationURO::baseNonRenderedUpdateRateURO' has a wrong offset!");
static_assert(offsetof(UAnimationURO, SkipFrameRateLOD) == 0x0000B0, "Member 'UAnimationURO::SkipFrameRateLOD' has a wrong offset!");

// Class Survival.BaseChaosVehiclePawn
// 0x0008 (0x0330 - 0x0328)
class ABaseChaosVehiclePawn final : public AWheeledVehiclePawn
{
public:
	class USkeletalMeshComponent*                 VehicleModel;                                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseChaosVehiclePawn">();
	}
	static class ABaseChaosVehiclePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseChaosVehiclePawn>();
	}
};
static_assert(alignof(ABaseChaosVehiclePawn) == 0x000008, "Wrong alignment on ABaseChaosVehiclePawn");
static_assert(sizeof(ABaseChaosVehiclePawn) == 0x000330, "Wrong size on ABaseChaosVehiclePawn");
static_assert(offsetof(ABaseChaosVehiclePawn, VehicleModel) == 0x000328, "Member 'ABaseChaosVehiclePawn::VehicleModel' has a wrong offset!");

// Class Survival.BFL_Loop
// 0x0000 (0x0028 - 0x0028)
class UBFL_Loop final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> ArraySortInt(const TArray<int32>& Arrayname, bool FromEnd);
	static TMap<class UObject*, int32> MapSortByValue(const TMap<class UObject*, int32>& Map, bool FromEnd);
	static TMap<class FString, int32> StringMapSortByInt(const TMap<class FString, int32>& Map, bool FromEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFL_Loop">();
	}
	static class UBFL_Loop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFL_Loop>();
	}
};
static_assert(alignof(UBFL_Loop) == 0x000008, "Wrong alignment on UBFL_Loop");
static_assert(sizeof(UBFL_Loop) == 0x000028, "Wrong size on UBFL_Loop");

// Class Survival.BP_TDBNavModifierVolume
// 0x0000 (0x02F0 - 0x02F0)
class ABP_TDBNavModifierVolume final : public ANavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BP_TDBNavModifierVolume">();
	}
	static class ABP_TDBNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_TDBNavModifierVolume>();
	}
};
static_assert(alignof(ABP_TDBNavModifierVolume) == 0x000008, "Wrong alignment on ABP_TDBNavModifierVolume");
static_assert(sizeof(ABP_TDBNavModifierVolume) == 0x0002F0, "Wrong size on ABP_TDBNavModifierVolume");

// Class Survival.BreathSystemReplication
// 0x0018 (0x00B8 - 0x00A0)
class UBreathSystemReplication : public UActorComponent
{
public:
	struct FBreathStateChangedStruct              BreathStateRep;                                    // 0x00A0(0x0014)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BreathStateRep();
	void OnStateChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreathSystemReplication">();
	}
	static class UBreathSystemReplication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreathSystemReplication>();
	}
};
static_assert(alignof(UBreathSystemReplication) == 0x000008, "Wrong alignment on UBreathSystemReplication");
static_assert(sizeof(UBreathSystemReplication) == 0x0000B8, "Wrong size on UBreathSystemReplication");
static_assert(offsetof(UBreathSystemReplication, BreathStateRep) == 0x0000A0, "Member 'UBreathSystemReplication::BreathStateRep' has a wrong offset!");

// Class Survival.CarWithZombie
// 0x0000 (0x0290 - 0x0290)
class ACarWithZombie : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarWithZombie">();
	}
	static class ACarWithZombie* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACarWithZombie>();
	}
};
static_assert(alignof(ACarWithZombie) == 0x000008, "Wrong alignment on ACarWithZombie");
static_assert(sizeof(ACarWithZombie) == 0x000290, "Wrong size on ACarWithZombie");

// Class Survival.RnnrSetVar
// 0x0000 (0x0028 - 0x0028)
class URnnrSetVar final : public UObject
{
public:
	static class UObject* SetBoolByName(class UObject* Target, class FName VarName, bool NewValue);
	static void SetVolumetricTranslucentShadow(class UPrimitiveComponent* Target, bool NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RnnrSetVar">();
	}
	static class URnnrSetVar* GetDefaultObj()
	{
		return GetDefaultObjImpl<URnnrSetVar>();
	}
};
static_assert(alignof(URnnrSetVar) == 0x000008, "Wrong alignment on URnnrSetVar");
static_assert(sizeof(URnnrSetVar) == 0x000028, "Wrong size on URnnrSetVar");

// Class Survival.CharacterHeadStim
// 0x0180 (0x07B0 - 0x0630)
class ACharacterHeadStim : public ACharacter
{
public:
	uint8                                         Pad_628[0x50];                                     // 0x0628(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LookAtLocationSocketName;                          // 0x0678(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x20];                                     // 0x0680(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CharacterRotation;                                 // 0x06A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Cinematic;                                         // 0x06B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B9[0x7];                                      // 0x06B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MoveInput;                                         // 0x06C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasMovementInput;                                  // 0x06D0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D1[0x7];                                      // 0x06D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Direction;                                         // 0x06D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMoving;                                          // 0x06E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E1[0x7];                                      // 0x06E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LastVelocityRotation;                              // 0x06E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LookingRotation;                                   // 0x0700(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLookingRotationChanged;                           // 0x0718(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_719[0x7];                                      // 0x0719(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PrevAimYaw;                                        // 0x0720(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AimYawRate;                                        // 0x0728(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Pitch;                                             // 0x0730(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AimYawDelta;                                       // 0x0738(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Yaw;                                               // 0x0740(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TPPCrouchWepOffset;                                // 0x0748(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastMovementInputRotation;                         // 0x0760(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	double                                        MoveInputVelocityDiff;                             // 0x0778(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        InputVelocityDot;                                  // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PrevLookingRotation;                               // 0x0788(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UDataTable*                             NegativeEffectDataTable;                           // 0x07A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateScreenSizeRate;                              // 0x07A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerScreenSize;                                  // 0x07AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CalculateVariablesCPP(float _DeltaTime);
	struct FHitResult MainLineTrace(float Distance, bool Debug);
	TArray<EUNegativeEffectType> NegativeEffectCalculate(EUNegativeEffectDamageType _negativeEffectDamageType, float _health, class FName _boneName, float _bleedChanceMultiplier, bool _armor);
	void OnRep_HasMovementInput();
	void OnSignificance(const ESignificanceLevel& OldSignificance, const ESignificanceLevel& Significance, bool bFinal);
	void ScreenSizeTimerElapsed();

	struct FVector GetLookAtLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHeadStim">();
	}
	static class ACharacterHeadStim* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterHeadStim>();
	}
};
static_assert(alignof(ACharacterHeadStim) == 0x000010, "Wrong alignment on ACharacterHeadStim");
static_assert(sizeof(ACharacterHeadStim) == 0x0007B0, "Wrong size on ACharacterHeadStim");
static_assert(offsetof(ACharacterHeadStim, LookAtLocationSocketName) == 0x000678, "Member 'ACharacterHeadStim::LookAtLocationSocketName' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, CharacterRotation) == 0x0006A0, "Member 'ACharacterHeadStim::CharacterRotation' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, Cinematic) == 0x0006B8, "Member 'ACharacterHeadStim::Cinematic' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, MoveInput) == 0x0006C0, "Member 'ACharacterHeadStim::MoveInput' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, HasMovementInput) == 0x0006D0, "Member 'ACharacterHeadStim::HasMovementInput' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, Direction) == 0x0006D8, "Member 'ACharacterHeadStim::Direction' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, IsMoving) == 0x0006E0, "Member 'ACharacterHeadStim::IsMoving' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, LastVelocityRotation) == 0x0006E8, "Member 'ACharacterHeadStim::LastVelocityRotation' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, LookingRotation) == 0x000700, "Member 'ACharacterHeadStim::LookingRotation' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, bLookingRotationChanged) == 0x000718, "Member 'ACharacterHeadStim::bLookingRotationChanged' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, PrevAimYaw) == 0x000720, "Member 'ACharacterHeadStim::PrevAimYaw' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, AimYawRate) == 0x000728, "Member 'ACharacterHeadStim::AimYawRate' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, Pitch) == 0x000730, "Member 'ACharacterHeadStim::Pitch' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, AimYawDelta) == 0x000738, "Member 'ACharacterHeadStim::AimYawDelta' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, Yaw) == 0x000740, "Member 'ACharacterHeadStim::Yaw' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, TPPCrouchWepOffset) == 0x000748, "Member 'ACharacterHeadStim::TPPCrouchWepOffset' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, LastMovementInputRotation) == 0x000760, "Member 'ACharacterHeadStim::LastMovementInputRotation' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, MoveInputVelocityDiff) == 0x000778, "Member 'ACharacterHeadStim::MoveInputVelocityDiff' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, InputVelocityDot) == 0x000780, "Member 'ACharacterHeadStim::InputVelocityDot' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, PrevLookingRotation) == 0x000788, "Member 'ACharacterHeadStim::PrevLookingRotation' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, NegativeEffectDataTable) == 0x0007A0, "Member 'ACharacterHeadStim::NegativeEffectDataTable' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, UpdateScreenSizeRate) == 0x0007A8, "Member 'ACharacterHeadStim::UpdateScreenSizeRate' has a wrong offset!");
static_assert(offsetof(ACharacterHeadStim, PlayerScreenSize) == 0x0007AC, "Member 'ACharacterHeadStim::PlayerScreenSize' has a wrong offset!");

// Class Survival.CustomATPCFadingObject
// 0x0000 (0x00E0 - 0x00E0)
class UCustomATPCFadingObject final : public UATPCCameraFadingObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomATPCFadingObject">();
	}
	static class UCustomATPCFadingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomATPCFadingObject>();
	}
};
static_assert(alignof(UCustomATPCFadingObject) == 0x000008, "Wrong alignment on UCustomATPCFadingObject");
static_assert(sizeof(UCustomATPCFadingObject) == 0x0000E0, "Wrong size on UCustomATPCFadingObject");

// Class Survival.CustomLevelStreamer
// 0x0000 (0x0290 - 0x0290)
class ACustomLevelStreamer final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomLevelStreamer">();
	}
	static class ACustomLevelStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomLevelStreamer>();
	}
};
static_assert(alignof(ACustomLevelStreamer) == 0x000008, "Wrong alignment on ACustomLevelStreamer");
static_assert(sizeof(ACustomLevelStreamer) == 0x000290, "Wrong size on ACustomLevelStreamer");

// Class Survival.EnvQueryTest_IsOccupiedByZombie
// 0x0030 (0x0228 - 0x01F8)
class UEnvQueryTest_IsOccupiedByZombie final : public UEnvQueryTest
{
public:
	float                                         AddZCoordinate;                                    // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawLine;                                          // 0x01FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 LineColor;                                         // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineLifeTime;                                      // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawSphere;                                        // 0x020C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SphereSegments;                                    // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SphereColor;                                       // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereLifeTime;                                    // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereThickness;                                   // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsOccupiedByZombie">();
	}
	static class UEnvQueryTest_IsOccupiedByZombie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsOccupiedByZombie>();
	}
};
static_assert(alignof(UEnvQueryTest_IsOccupiedByZombie) == 0x000008, "Wrong alignment on UEnvQueryTest_IsOccupiedByZombie");
static_assert(sizeof(UEnvQueryTest_IsOccupiedByZombie) == 0x000228, "Wrong size on UEnvQueryTest_IsOccupiedByZombie");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, AddZCoordinate) == 0x0001F8, "Member 'UEnvQueryTest_IsOccupiedByZombie::AddZCoordinate' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, DrawLine) == 0x0001FC, "Member 'UEnvQueryTest_IsOccupiedByZombie::DrawLine' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, LineColor) == 0x000200, "Member 'UEnvQueryTest_IsOccupiedByZombie::LineColor' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, LineLifeTime) == 0x000204, "Member 'UEnvQueryTest_IsOccupiedByZombie::LineLifeTime' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, LineThickness) == 0x000208, "Member 'UEnvQueryTest_IsOccupiedByZombie::LineThickness' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, DrawSphere) == 0x00020C, "Member 'UEnvQueryTest_IsOccupiedByZombie::DrawSphere' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, SphereRadius) == 0x000210, "Member 'UEnvQueryTest_IsOccupiedByZombie::SphereRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, SphereSegments) == 0x000214, "Member 'UEnvQueryTest_IsOccupiedByZombie::SphereSegments' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, SphereColor) == 0x000218, "Member 'UEnvQueryTest_IsOccupiedByZombie::SphereColor' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, SphereLifeTime) == 0x00021C, "Member 'UEnvQueryTest_IsOccupiedByZombie::SphereLifeTime' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsOccupiedByZombie, SphereThickness) == 0x000220, "Member 'UEnvQueryTest_IsOccupiedByZombie::SphereThickness' has a wrong offset!");

// Class Survival.FL_SteamHelper
// 0x0000 (0x0028 - 0x0028)
class UFL_SteamHelper final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetSteamAuthenticateUserTicket();
	static class FString GetSteamUserCountryCode();
	static class FString GetSteamUserIDString();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FL_SteamHelper">();
	}
	static class UFL_SteamHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFL_SteamHelper>();
	}
};
static_assert(alignof(UFL_SteamHelper) == 0x000008, "Wrong alignment on UFL_SteamHelper");
static_assert(sizeof(UFL_SteamHelper) == 0x000028, "Wrong size on UFL_SteamHelper");

// Class Survival.FPSProjectile
// 0x0010 (0x02A0 - 0x0290)
class AFPSProjectile final : public AActor
{
public:
	class USphereComponent*                       CollisionComponent;                                // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FPSProjectile">();
	}
	static class AFPSProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFPSProjectile>();
	}
};
static_assert(alignof(AFPSProjectile) == 0x000008, "Wrong alignment on AFPSProjectile");
static_assert(sizeof(AFPSProjectile) == 0x0002A0, "Wrong size on AFPSProjectile");
static_assert(offsetof(AFPSProjectile, CollisionComponent) == 0x000290, "Member 'AFPSProjectile::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AFPSProjectile, ProjectileMovementComponent) == 0x000298, "Member 'AFPSProjectile::ProjectileMovementComponent' has a wrong offset!");

// Class Survival.GameHUD
// 0x0000 (0x0380 - 0x0380)
class AGameHUD : public AHUD
{
public:
	void SetUI(EUIType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHUD">();
	}
	static class AGameHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameHUD>();
	}
};
static_assert(alignof(AGameHUD) == 0x000008, "Wrong alignment on AGameHUD");
static_assert(sizeof(AGameHUD) == 0x000380, "Wrong size on AGameHUD");

// Class Survival.GoreComponent
// 0x0090 (0x0130 - 0x00A0)
class UGoreComponent final : public UActorComponent
{
public:
	float                                         HitTolerance;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HitLocationName;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EllipsoidName;                                     // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGib>                Gibs;                                              // 0x00C8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x0118(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         HitLocationCount;                                  // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               OwnerMaterial;                                     // 0x0128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static struct FVector TransformHitLocationToSkeletonRelative(const struct FVector& HitLocation, const class USkeletalMeshComponent* Mesh, const class FName& BoneName);

	bool CriticalDamaged();
	void DestroyLimb(const class FName& BoneName, const struct FVector& HitLocation);
	void SetOwnerMesh(class USkeletalMeshComponent* Mesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoreComponent">();
	}
	static class UGoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoreComponent>();
	}
};
static_assert(alignof(UGoreComponent) == 0x000008, "Wrong alignment on UGoreComponent");
static_assert(sizeof(UGoreComponent) == 0x000130, "Wrong size on UGoreComponent");
static_assert(offsetof(UGoreComponent, HitTolerance) == 0x0000A0, "Member 'UGoreComponent::HitTolerance' has a wrong offset!");
static_assert(offsetof(UGoreComponent, HitLocationName) == 0x0000A8, "Member 'UGoreComponent::HitLocationName' has a wrong offset!");
static_assert(offsetof(UGoreComponent, EllipsoidName) == 0x0000B8, "Member 'UGoreComponent::EllipsoidName' has a wrong offset!");
static_assert(offsetof(UGoreComponent, Gibs) == 0x0000C8, "Member 'UGoreComponent::Gibs' has a wrong offset!");
static_assert(offsetof(UGoreComponent, OwnerMesh) == 0x000118, "Member 'UGoreComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(UGoreComponent, HitLocationCount) == 0x000120, "Member 'UGoreComponent::HitLocationCount' has a wrong offset!");
static_assert(offsetof(UGoreComponent, OwnerMaterial) == 0x000128, "Member 'UGoreComponent::OwnerMaterial' has a wrong offset!");

// Class Survival.HelicopterPatrol
// 0x0000 (0x0290 - 0x0290)
class AHelicopterPatrol final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterPatrol">();
	}
	static class AHelicopterPatrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelicopterPatrol>();
	}
};
static_assert(alignof(AHelicopterPatrol) == 0x000008, "Wrong alignment on AHelicopterPatrol");
static_assert(sizeof(AHelicopterPatrol) == 0x000290, "Wrong size on AHelicopterPatrol");

// Class Survival.SignificanceInterface
// 0x0000 (0x0028 - 0x0028)
class ISignificanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignificanceInterface">();
	}
	static class ISignificanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISignificanceInterface>();
	}
};
static_assert(alignof(ISignificanceInterface) == 0x000008, "Wrong alignment on ISignificanceInterface");
static_assert(sizeof(ISignificanceInterface) == 0x000028, "Wrong size on ISignificanceInterface");

// Class Survival.LevelLoadDetector
// 0x0030 (0x02C0 - 0x0290)
class ALevelLoadDetector : public AActor
{
public:
	TArray<class ULevelStreaming*>                Levels;                                            // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStreamedLevelLoaded;                             // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStreamedLevelUnloaded;                           // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnLevelStreamed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelLoadDetector">();
	}
	static class ALevelLoadDetector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelLoadDetector>();
	}
};
static_assert(alignof(ALevelLoadDetector) == 0x000008, "Wrong alignment on ALevelLoadDetector");
static_assert(sizeof(ALevelLoadDetector) == 0x0002C0, "Wrong size on ALevelLoadDetector");
static_assert(offsetof(ALevelLoadDetector, Levels) == 0x000290, "Member 'ALevelLoadDetector::Levels' has a wrong offset!");
static_assert(offsetof(ALevelLoadDetector, OnStreamedLevelLoaded) == 0x0002A0, "Member 'ALevelLoadDetector::OnStreamedLevelLoaded' has a wrong offset!");
static_assert(offsetof(ALevelLoadDetector, OnStreamedLevelUnloaded) == 0x0002B0, "Member 'ALevelLoadDetector::OnStreamedLevelUnloaded' has a wrong offset!");

// Class Survival.LootGeneratorDataAsset
// 0x0020 (0x0050 - 0x0030)
class ULootGeneratorDataAsset final : public UDataAsset
{
public:
	int32                                         MinItems;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxItems;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSItemTypeBalance>              ItemTypeBalance;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTable;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootGeneratorDataAsset">();
	}
	static class ULootGeneratorDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootGeneratorDataAsset>();
	}
};
static_assert(alignof(ULootGeneratorDataAsset) == 0x000008, "Wrong alignment on ULootGeneratorDataAsset");
static_assert(sizeof(ULootGeneratorDataAsset) == 0x000050, "Wrong size on ULootGeneratorDataAsset");
static_assert(offsetof(ULootGeneratorDataAsset, MinItems) == 0x000030, "Member 'ULootGeneratorDataAsset::MinItems' has a wrong offset!");
static_assert(offsetof(ULootGeneratorDataAsset, MaxItems) == 0x000034, "Member 'ULootGeneratorDataAsset::MaxItems' has a wrong offset!");
static_assert(offsetof(ULootGeneratorDataAsset, ItemTypeBalance) == 0x000038, "Member 'ULootGeneratorDataAsset::ItemTypeBalance' has a wrong offset!");
static_assert(offsetof(ULootGeneratorDataAsset, DataTable) == 0x000048, "Member 'ULootGeneratorDataAsset::DataTable' has a wrong offset!");

// Class Survival.MainContainerBox
// 0x0000 (0x0290 - 0x0290)
class AMainContainerBox : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainContainerBox">();
	}
	static class AMainContainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainContainerBox>();
	}
};
static_assert(alignof(AMainContainerBox) == 0x000008, "Wrong alignment on AMainContainerBox");
static_assert(sizeof(AMainContainerBox) == 0x000290, "Wrong size on AMainContainerBox");

// Class Survival.MyWorldSettings
// 0x0000 (0x04B8 - 0x04B8)
class AMyWorldSettings final : public AWorldSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyWorldSettings">();
	}
	static class AMyWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyWorldSettings>();
	}
};
static_assert(alignof(AMyWorldSettings) == 0x000008, "Wrong alignment on AMyWorldSettings");
static_assert(sizeof(AMyWorldSettings) == 0x0004B8, "Wrong size on AMyWorldSettings");

// Class Survival.PathToAnimal
// 0x0000 (0x0028 - 0x0028)
class UPathToAnimal final : public UBlueprintFunctionLibrary
{
public:
	static void AddAnimalStep(const struct FAnimalSteps& Steps, class AActor* Actor, TArray<class AActor*>* ReturnedSteps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathToAnimal">();
	}
	static class UPathToAnimal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathToAnimal>();
	}
};
static_assert(alignof(UPathToAnimal) == 0x000008, "Wrong alignment on UPathToAnimal");
static_assert(sizeof(UPathToAnimal) == 0x000028, "Wrong size on UPathToAnimal");

// Class Survival.ProjectileBullet
// 0x0088 (0x0318 - 0x0290)
class AProjectileBullet : public AActor
{
public:
	class UCurveFloat*                            DragCoefficient;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       Sphere;                                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraParticleTrail;                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalSpeed;                                        // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bulletArea;                                        // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDensity;                                        // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileVelocity;                                // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastPosition;                                      // 0x02D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x02F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowTrace;                                         // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector CalcVelocity();
	void InitBullet(float bulletSpeedMultiplier, float bulletSlowCoef, float bulletSpeed, float bulletSpeedFinal);
	void InitBulletParam(float FMass, float FTrueCaliber);
	void OnProjectileCalculate();
	void OnProjectileOnce();
	float ProjectileOnceTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileBullet">();
	}
	static class AProjectileBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileBullet>();
	}
};
static_assert(alignof(AProjectileBullet) == 0x000008, "Wrong alignment on AProjectileBullet");
static_assert(sizeof(AProjectileBullet) == 0x000318, "Wrong size on AProjectileBullet");
static_assert(offsetof(AProjectileBullet, DragCoefficient) == 0x000290, "Member 'AProjectileBullet::DragCoefficient' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, Sphere) == 0x0002A8, "Member 'AProjectileBullet::Sphere' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, ProjectileMovement) == 0x0002B0, "Member 'AProjectileBullet::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, NiagaraParticleTrail) == 0x0002B8, "Member 'AProjectileBullet::NiagaraParticleTrail' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, InitialSpeed) == 0x0002C0, "Member 'AProjectileBullet::InitialSpeed' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, FinalSpeed) == 0x0002C4, "Member 'AProjectileBullet::FinalSpeed' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, Mass) == 0x0002C8, "Member 'AProjectileBullet::Mass' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, bulletArea) == 0x0002CC, "Member 'AProjectileBullet::bulletArea' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, AirDensity) == 0x0002D0, "Member 'AProjectileBullet::AirDensity' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, ProjectileVelocity) == 0x0002D4, "Member 'AProjectileBullet::ProjectileVelocity' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, LastPosition) == 0x0002D8, "Member 'AProjectileBullet::LastPosition' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, SpawnLocation) == 0x0002F0, "Member 'AProjectileBullet::SpawnLocation' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, ShowTrace) == 0x000308, "Member 'AProjectileBullet::ShowTrace' has a wrong offset!");
static_assert(offsetof(AProjectileBullet, NiagaraSystem) == 0x000310, "Member 'AProjectileBullet::NiagaraSystem' has a wrong offset!");

// Class Survival.ProjectileReplicatedActor
// 0x0008 (0x0298 - 0x0290)
class AProjectileReplicatedActor final : public AActor
{
public:
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileReplicatedActor">();
	}
	static class AProjectileReplicatedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileReplicatedActor>();
	}
};
static_assert(alignof(AProjectileReplicatedActor) == 0x000008, "Wrong alignment on AProjectileReplicatedActor");
static_assert(sizeof(AProjectileReplicatedActor) == 0x000298, "Wrong size on AProjectileReplicatedActor");
static_assert(offsetof(AProjectileReplicatedActor, ProjectileMovement) == 0x000290, "Member 'AProjectileReplicatedActor::ProjectileMovement' has a wrong offset!");

// Class Survival.RBVehicle
// 0x0018 (0x0330 - 0x0318)
class ARBVehicle : public APawn
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PhysicsTick(float SubstepDeltaTime);
	void UpdateLastMove(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBVehicle">();
	}
	static class ARBVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARBVehicle>();
	}
};
static_assert(alignof(ARBVehicle) == 0x000008, "Wrong alignment on ARBVehicle");
static_assert(sizeof(ARBVehicle) == 0x000330, "Wrong size on ARBVehicle");
static_assert(offsetof(ARBVehicle, Mesh) == 0x000328, "Member 'ARBVehicle::Mesh' has a wrong offset!");

// Class Survival.SmoothSync
// 0x02C0 (0x0360 - 0x00A0)
class alignas(0x10) USmoothSync : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x58];                                      // 0x00A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationBackTime;                             // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ExtrapolationMode                             ExtrapolationMode;                                 // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseExtrapolationTimeLimit;                         // 0x00FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtrapolationTimeLimit;                            // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseExtrapolationDistanceLimit;                     // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtrapolationDistanceLimit;                        // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendPositionThreshold;                             // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendRotationThreshold;                             // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendScaleThreshold;                                // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendVelocityThreshold;                             // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendAngularVelocityThreshold;                      // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedPositionThreshold;                         // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedRotationThreshold;                         // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionSnapThreshold;                             // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSnapThreshold;                             // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSnapThreshold;                                // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSmoothing;                                     // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionLerpSpeed;                                 // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLerpSpeed;                                 // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleLerpSpeed;                                    // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyncMode                                     SyncPosition;                                      // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyncMode                                     SyncRotation;                                      // 0x0145(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyncMode                                     SyncScale;                                         // 0x0146(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyncMode                                     SyncVelocity;                                      // 0x0147(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyncMode                                     SyncAngularVelocity;                               // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SyncMovementMode;                                  // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPositionCompressed;                              // 0x014A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRotationCompressed;                              // 0x014B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsScaleCompressed;                                 // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVelocityCompressed;                              // 0x014D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAngularVelocityCompressed;                       // 0x014E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F[0x1];                                      // 0x014F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SendRate;                                          // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsingOriginRebasing;                             // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysSendOrigin;                                  // 0x0155(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SyncOwnershipChange;                               // 0x0156(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157[0x91];                                     // 0x0157(0x0091)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RealComponentToSync;                               // 0x01E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x18];                                     // 0x01F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationTime;                                 // 0x0208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x134];                                    // 0x020C(0x0134)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AtRestPositionThreshold;                           // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtRestRotationThreshold;                           // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0xC];                                      // 0x0348(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          StopGetState;                                      // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355[0xB];                                      // 0x0355(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearBuffer();
	void ClientSendsTransformToServer(const TArray<uint8>& Value);
	void EnableSmoothSync(bool Enable);
	void ForceStateSendNextFrame();
	void ServerSendsTransformToEveryone(const TArray<uint8>& Value);
	void SetSceneComponentToSync(class USceneComponent* TheComponent);
	void SmoothSyncEnableClientToServer(bool Enable);
	void SmoothSyncEnableServerToClients(bool Enable);
	void SmoothSyncTeleportClientToServer(const struct FVector3f& Position, const struct FVector3f& Rotation, const struct FVector3f& Scale, float TempOwnerTime);
	void SmoothSyncTeleportServerToClients(const struct FVector3f& Position, const struct FVector3f& Rotation, const struct FVector3f& Scale, float TempOwnerTime);
	void Teleport();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothSync">();
	}
	static class USmoothSync* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothSync>();
	}
};
static_assert(alignof(USmoothSync) == 0x000010, "Wrong alignment on USmoothSync");
static_assert(sizeof(USmoothSync) == 0x000360, "Wrong size on USmoothSync");
static_assert(offsetof(USmoothSync, InterpolationBackTime) == 0x0000F8, "Member 'USmoothSync::InterpolationBackTime' has a wrong offset!");
static_assert(offsetof(USmoothSync, ExtrapolationMode) == 0x0000FC, "Member 'USmoothSync::ExtrapolationMode' has a wrong offset!");
static_assert(offsetof(USmoothSync, UseExtrapolationTimeLimit) == 0x0000FD, "Member 'USmoothSync::UseExtrapolationTimeLimit' has a wrong offset!");
static_assert(offsetof(USmoothSync, ExtrapolationTimeLimit) == 0x000100, "Member 'USmoothSync::ExtrapolationTimeLimit' has a wrong offset!");
static_assert(offsetof(USmoothSync, UseExtrapolationDistanceLimit) == 0x000104, "Member 'USmoothSync::UseExtrapolationDistanceLimit' has a wrong offset!");
static_assert(offsetof(USmoothSync, ExtrapolationDistanceLimit) == 0x000108, "Member 'USmoothSync::ExtrapolationDistanceLimit' has a wrong offset!");
static_assert(offsetof(USmoothSync, SendPositionThreshold) == 0x00010C, "Member 'USmoothSync::SendPositionThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, SendRotationThreshold) == 0x000110, "Member 'USmoothSync::SendRotationThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, SendScaleThreshold) == 0x000114, "Member 'USmoothSync::SendScaleThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, SendVelocityThreshold) == 0x000118, "Member 'USmoothSync::SendVelocityThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, SendAngularVelocityThreshold) == 0x00011C, "Member 'USmoothSync::SendAngularVelocityThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, ReceivedPositionThreshold) == 0x000120, "Member 'USmoothSync::ReceivedPositionThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, ReceivedRotationThreshold) == 0x000124, "Member 'USmoothSync::ReceivedRotationThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, PositionSnapThreshold) == 0x000128, "Member 'USmoothSync::PositionSnapThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, RotationSnapThreshold) == 0x00012C, "Member 'USmoothSync::RotationSnapThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, ScaleSnapThreshold) == 0x000130, "Member 'USmoothSync::ScaleSnapThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, TimeSmoothing) == 0x000134, "Member 'USmoothSync::TimeSmoothing' has a wrong offset!");
static_assert(offsetof(USmoothSync, PositionLerpSpeed) == 0x000138, "Member 'USmoothSync::PositionLerpSpeed' has a wrong offset!");
static_assert(offsetof(USmoothSync, RotationLerpSpeed) == 0x00013C, "Member 'USmoothSync::RotationLerpSpeed' has a wrong offset!");
static_assert(offsetof(USmoothSync, ScaleLerpSpeed) == 0x000140, "Member 'USmoothSync::ScaleLerpSpeed' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncPosition) == 0x000144, "Member 'USmoothSync::SyncPosition' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncRotation) == 0x000145, "Member 'USmoothSync::SyncRotation' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncScale) == 0x000146, "Member 'USmoothSync::SyncScale' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncVelocity) == 0x000147, "Member 'USmoothSync::SyncVelocity' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncAngularVelocity) == 0x000148, "Member 'USmoothSync::SyncAngularVelocity' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncMovementMode) == 0x000149, "Member 'USmoothSync::SyncMovementMode' has a wrong offset!");
static_assert(offsetof(USmoothSync, IsPositionCompressed) == 0x00014A, "Member 'USmoothSync::IsPositionCompressed' has a wrong offset!");
static_assert(offsetof(USmoothSync, IsRotationCompressed) == 0x00014B, "Member 'USmoothSync::IsRotationCompressed' has a wrong offset!");
static_assert(offsetof(USmoothSync, IsScaleCompressed) == 0x00014C, "Member 'USmoothSync::IsScaleCompressed' has a wrong offset!");
static_assert(offsetof(USmoothSync, IsVelocityCompressed) == 0x00014D, "Member 'USmoothSync::IsVelocityCompressed' has a wrong offset!");
static_assert(offsetof(USmoothSync, IsAngularVelocityCompressed) == 0x00014E, "Member 'USmoothSync::IsAngularVelocityCompressed' has a wrong offset!");
static_assert(offsetof(USmoothSync, SendRate) == 0x000150, "Member 'USmoothSync::SendRate' has a wrong offset!");
static_assert(offsetof(USmoothSync, IsUsingOriginRebasing) == 0x000154, "Member 'USmoothSync::IsUsingOriginRebasing' has a wrong offset!");
static_assert(offsetof(USmoothSync, AlwaysSendOrigin) == 0x000155, "Member 'USmoothSync::AlwaysSendOrigin' has a wrong offset!");
static_assert(offsetof(USmoothSync, SyncOwnershipChange) == 0x000156, "Member 'USmoothSync::SyncOwnershipChange' has a wrong offset!");
static_assert(offsetof(USmoothSync, RealComponentToSync) == 0x0001E8, "Member 'USmoothSync::RealComponentToSync' has a wrong offset!");
static_assert(offsetof(USmoothSync, InterpolationTime) == 0x000208, "Member 'USmoothSync::InterpolationTime' has a wrong offset!");
static_assert(offsetof(USmoothSync, AtRestPositionThreshold) == 0x000340, "Member 'USmoothSync::AtRestPositionThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, AtRestRotationThreshold) == 0x000344, "Member 'USmoothSync::AtRestRotationThreshold' has a wrong offset!");
static_assert(offsetof(USmoothSync, StopGetState) == 0x000354, "Member 'USmoothSync::StopGetState' has a wrong offset!");

// Class Survival.StaticMeshComponentWithItsOwnFOV
// 0x0010 (0x0630 - 0x0620)
class UStaticMeshComponentWithItsOwnFOV final : public UStaticMeshComponent
{
public:
	float                                         DesiredHorizontalFov;                              // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponFOV;                                         // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOwnFOV;                                         // 0x0628(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshComponentWithItsOwnFOV">();
	}
	static class UStaticMeshComponentWithItsOwnFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshComponentWithItsOwnFOV>();
	}
};
static_assert(alignof(UStaticMeshComponentWithItsOwnFOV) == 0x000010, "Wrong alignment on UStaticMeshComponentWithItsOwnFOV");
static_assert(sizeof(UStaticMeshComponentWithItsOwnFOV) == 0x000630, "Wrong size on UStaticMeshComponentWithItsOwnFOV");
static_assert(offsetof(UStaticMeshComponentWithItsOwnFOV, DesiredHorizontalFov) == 0x000620, "Member 'UStaticMeshComponentWithItsOwnFOV::DesiredHorizontalFov' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponentWithItsOwnFOV, WeaponFOV) == 0x000624, "Member 'UStaticMeshComponentWithItsOwnFOV::WeaponFOV' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponentWithItsOwnFOV, UseOwnFOV) == 0x000628, "Member 'UStaticMeshComponentWithItsOwnFOV::UseOwnFOV' has a wrong offset!");

// Class Survival.SurvCameraFOVObject
// 0x0030 (0x0060 - 0x0030)
class USurvCameraFOVObject : public UATPCCameraFOVObject
{
public:
	bool                                          IsOverride;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HandledCineCamera;                                 // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadingAddingFOV;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FATPCInterploationSpeed                ReloadingFOVInterpolation;                         // 0x0038(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ReloadingFOVModifier;                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CameraReset();
	void SwitchReloadingFOV(bool IsReloadingFOV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvCameraFOVObject">();
	}
	static class USurvCameraFOVObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvCameraFOVObject>();
	}
};
static_assert(alignof(USurvCameraFOVObject) == 0x000008, "Wrong alignment on USurvCameraFOVObject");
static_assert(sizeof(USurvCameraFOVObject) == 0x000060, "Wrong size on USurvCameraFOVObject");
static_assert(offsetof(USurvCameraFOVObject, IsOverride) == 0x000030, "Member 'USurvCameraFOVObject::IsOverride' has a wrong offset!");
static_assert(offsetof(USurvCameraFOVObject, HandledCineCamera) == 0x000031, "Member 'USurvCameraFOVObject::HandledCineCamera' has a wrong offset!");
static_assert(offsetof(USurvCameraFOVObject, ReloadingAddingFOV) == 0x000034, "Member 'USurvCameraFOVObject::ReloadingAddingFOV' has a wrong offset!");
static_assert(offsetof(USurvCameraFOVObject, ReloadingFOVInterpolation) == 0x000038, "Member 'USurvCameraFOVObject::ReloadingFOVInterpolation' has a wrong offset!");
static_assert(offsetof(USurvCameraFOVObject, ReloadingFOVModifier) == 0x000050, "Member 'USurvCameraFOVObject::ReloadingFOVModifier' has a wrong offset!");

// Class Survival.SurvCameraLocationObject
// 0x00E8 (0x04C0 - 0x03D8)
class USurvCameraLocationObject : public UATPCCameraLocationObject
{
public:
	struct FATPCInterploationSpeed                AimingSocketOffset;                                // 0x03D8(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AimingLerpInterpolateSpeed;                        // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x17];                                     // 0x03F0(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAiming;                                         // 0x0407(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0xB8];                                     // 0x0408(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AimingLerp();
	void CameraChange();
	void CameraOverrideSocket(const struct FVector& OffsetVector, bool bReset);
	void CameraOverrideTarget(const struct FVector& OffsetVector, bool bReset);
	void CameraOverrideTickBlock(bool bBlock);
	void CameraSpeedReset();
	void CustomLerp(const struct FVector& StartSocketVector, float LerpLenght, bool CustomLerpOffset, EEasingFunc LerpType, float BlendExp, int32 Steps, bool X, bool Y, bool Z);
	class UCurveVector* GetCurrentSocketVector();
	void SetSocketAdditionalOffset(const struct FVector& OffsetVector, float bInterpSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvCameraLocationObject">();
	}
	static class USurvCameraLocationObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvCameraLocationObject>();
	}
};
static_assert(alignof(USurvCameraLocationObject) == 0x000008, "Wrong alignment on USurvCameraLocationObject");
static_assert(sizeof(USurvCameraLocationObject) == 0x0004C0, "Wrong size on USurvCameraLocationObject");
static_assert(offsetof(USurvCameraLocationObject, AimingSocketOffset) == 0x0003D8, "Member 'USurvCameraLocationObject::AimingSocketOffset' has a wrong offset!");
static_assert(offsetof(USurvCameraLocationObject, AimingLerpInterpolateSpeed) == 0x0003EC, "Member 'USurvCameraLocationObject::AimingLerpInterpolateSpeed' has a wrong offset!");
static_assert(offsetof(USurvCameraLocationObject, bIsAiming) == 0x000407, "Member 'USurvCameraLocationObject::bIsAiming' has a wrong offset!");

// Class Survival.SurvivalATPCCameraComponent
// 0x0000 (0x0700 - 0x0700)
class USurvivalATPCCameraComponent : public UATPCCameraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalATPCCameraComponent">();
	}
	static class USurvivalATPCCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivalATPCCameraComponent>();
	}
};
static_assert(alignof(USurvivalATPCCameraComponent) == 0x000010, "Wrong alignment on USurvivalATPCCameraComponent");
static_assert(sizeof(USurvivalATPCCameraComponent) == 0x000700, "Wrong size on USurvivalATPCCameraComponent");

// Class Survival.SurvivalGameInstance
// 0x0028 (0x0218 - 0x01F0)
class USurvivalGameInstance : public UBE_GameInstance
{
public:
	class UUserWidget*                            WidgetObject;                                      // 0x01F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                LoadingScreenWidgetClass;                          // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLoadingScreenShown;                             // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SteamSessionTicket;                                // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static int64 GetShadersRemaining();

	void FadeScreen(const float Duration, const bool bToFade, const struct FLinearColor& ToColor);
	bool GetGPUAMD();
	class FString GetGPUBrandName();
	bool GetGPUNVidia();
	void HideLoadingScreen();
	void SetBatchMode(int32 batchMode);
	void ShowLoadingScreen();
	class FString UpdateSteamSessionTicket();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalGameInstance">();
	}
	static class USurvivalGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivalGameInstance>();
	}
};
static_assert(alignof(USurvivalGameInstance) == 0x000008, "Wrong alignment on USurvivalGameInstance");
static_assert(sizeof(USurvivalGameInstance) == 0x000218, "Wrong size on USurvivalGameInstance");
static_assert(offsetof(USurvivalGameInstance, WidgetObject) == 0x0001F0, "Member 'USurvivalGameInstance::WidgetObject' has a wrong offset!");
static_assert(offsetof(USurvivalGameInstance, LoadingScreenWidgetClass) == 0x0001F8, "Member 'USurvivalGameInstance::LoadingScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(USurvivalGameInstance, bIsLoadingScreenShown) == 0x000200, "Member 'USurvivalGameInstance::bIsLoadingScreenShown' has a wrong offset!");
static_assert(offsetof(USurvivalGameInstance, SteamSessionTicket) == 0x000208, "Member 'USurvivalGameInstance::SteamSessionTicket' has a wrong offset!");

// Class Survival.SurvivalGameMode
// 0x0058 (0x03E0 - 0x0388)
class ASurvivalGameMode : public ABE_GameMode
{
public:
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class APlayerController*> GetAllPlayerController();
	bool KickPlayerCustom(class APlayerController* TargetPlayer, const class FText& KickReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalGameMode">();
	}
	static class ASurvivalGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASurvivalGameMode>();
	}
};
static_assert(alignof(ASurvivalGameMode) == 0x000008, "Wrong alignment on ASurvivalGameMode");
static_assert(sizeof(ASurvivalGameMode) == 0x0003E0, "Wrong size on ASurvivalGameMode");

// Class Survival.SurvivalGameUserSettings
// 0x0070 (0x01B8 - 0x0148)
class USurvivalGameUserSettings final : public UGameUserSettings
{
public:
	float                                         MasterVolume;                                      // 0x0148(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectsVolume;                                     // 0x014C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DialogVolume;                                      // 0x0150(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MusicVolume;                                       // 0x0154(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoiceChatVolume;                                   // 0x0158(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseSensitivity;                                  // 0x015C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UserRenderingAPI;                                  // 0x0160(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonitorIndex;                                      // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseThreadedRenderer;                              // 0x0168(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TextCulture;                                       // 0x0170(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 VoiceCulture;                                      // 0x0180(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VoiceLinesEnabled;                                 // 0x0190(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TextChatEnabled;                                   // 0x0191(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VoiceChatEnabled;                                  // 0x0192(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowGameData;                                     // 0x0193(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MouseInverse;                                      // 0x0194(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RayTracing;                                        // 0x0195(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_196[0x2];                                      // 0x0196(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GlobalIllumination;                                // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Reflection;                                        // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DLSS;                                              // 0x01A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NIS;                                               // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReflexMode;                                        // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FrameGeneration;                                   // 0x01AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FSR2;                                              // 0x01B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CustomShadowQuality;                               // 0x01B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static void HideWindowBorder();
	static void ShowWindowBorder();

	void ApplyFullscreenMode(bool bCheckForCommandLineOverrides);
	void ApplyThreadedRenderer();
	bool GetAllowGameData();
	int32 GetCustomShadowQuality();
	float GetDialogVolume();
	int32 GetDLSS();
	float GetEffectsVolume();
	bool GetFrameGeneration();
	int32 GetFSR2();
	int32 GetGlobalIllumination();
	float GetMasterVolume();
	int32 GetMonitorIndex();
	bool GetMouseInverse();
	float GetMouseSensitivity();
	float GetMusicVolume();
	int32 GetNIS();
	bool GetRayTracing();
	int32 GetReflection();
	int32 GetReflexMode();
	bool GetTextChatEnabled();
	class FString GetTextCulture();
	int32 GetUserRenderingAPI();
	bool GetVoiceChatEnabled();
	float GetVoiceChatVolume();
	class FString GetVoiceCulture();
	bool GetVoiceLinesEnabled();
	bool IsThreadedRenderer();
	void SetAllowGameData(bool Allow);
	void SetCustomShadowQuality(int32 Param_Index);
	void SetDialogVolume(float Volume);
	void SetDLSS(int32 Param_Index);
	void SetEffectsVolume(float Volume);
	void SetFrameGeneration(bool Enabled);
	void SetFSR2(int32 Param_Index);
	void SetGlobalIllumination(int32 Param_Index);
	void SetGraphicsAPI(ESurvivalRHI API);
	void SetMasterVolume(float Volume);
	void SetMonitorIndex(int32 Param_Index);
	void SetMouseInverse(bool Inverse);
	void SetMouseSensitivity(float Sensitivity);
	void SetMusicVolume(float Volume);
	void SetNIS(int32 Param_Index);
	void SetRayTracing(bool Enabled);
	void SetReflection(int32 Param_Index);
	void SetReflexMode(int32 Param_Index);
	void SetTextChatEnabled(bool Enabled);
	void SetTextCulture(const class FString& Culture);
	void SetUseThreadedRenderer(bool bAllowed);
	void SetVoiceChatEnabled(bool Enabled);
	void SetVoiceChatVolume(float Volume);
	void SetVoiceCulture(const class FString& Culture);
	void SetVoiceLinesEnabled(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalGameUserSettings">();
	}
	static class USurvivalGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivalGameUserSettings>();
	}
};
static_assert(alignof(USurvivalGameUserSettings) == 0x000008, "Wrong alignment on USurvivalGameUserSettings");
static_assert(sizeof(USurvivalGameUserSettings) == 0x0001B8, "Wrong size on USurvivalGameUserSettings");
static_assert(offsetof(USurvivalGameUserSettings, MasterVolume) == 0x000148, "Member 'USurvivalGameUserSettings::MasterVolume' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, EffectsVolume) == 0x00014C, "Member 'USurvivalGameUserSettings::EffectsVolume' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, DialogVolume) == 0x000150, "Member 'USurvivalGameUserSettings::DialogVolume' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, MusicVolume) == 0x000154, "Member 'USurvivalGameUserSettings::MusicVolume' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, VoiceChatVolume) == 0x000158, "Member 'USurvivalGameUserSettings::VoiceChatVolume' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, MouseSensitivity) == 0x00015C, "Member 'USurvivalGameUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, UserRenderingAPI) == 0x000160, "Member 'USurvivalGameUserSettings::UserRenderingAPI' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, MonitorIndex) == 0x000164, "Member 'USurvivalGameUserSettings::MonitorIndex' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, bUseThreadedRenderer) == 0x000168, "Member 'USurvivalGameUserSettings::bUseThreadedRenderer' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, TextCulture) == 0x000170, "Member 'USurvivalGameUserSettings::TextCulture' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, VoiceCulture) == 0x000180, "Member 'USurvivalGameUserSettings::VoiceCulture' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, VoiceLinesEnabled) == 0x000190, "Member 'USurvivalGameUserSettings::VoiceLinesEnabled' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, TextChatEnabled) == 0x000191, "Member 'USurvivalGameUserSettings::TextChatEnabled' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, VoiceChatEnabled) == 0x000192, "Member 'USurvivalGameUserSettings::VoiceChatEnabled' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, AllowGameData) == 0x000193, "Member 'USurvivalGameUserSettings::AllowGameData' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, MouseInverse) == 0x000194, "Member 'USurvivalGameUserSettings::MouseInverse' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, RayTracing) == 0x000195, "Member 'USurvivalGameUserSettings::RayTracing' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, GlobalIllumination) == 0x000198, "Member 'USurvivalGameUserSettings::GlobalIllumination' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, Reflection) == 0x00019C, "Member 'USurvivalGameUserSettings::Reflection' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, DLSS) == 0x0001A0, "Member 'USurvivalGameUserSettings::DLSS' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, NIS) == 0x0001A4, "Member 'USurvivalGameUserSettings::NIS' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, ReflexMode) == 0x0001A8, "Member 'USurvivalGameUserSettings::ReflexMode' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, FrameGeneration) == 0x0001AC, "Member 'USurvivalGameUserSettings::FrameGeneration' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, FSR2) == 0x0001B0, "Member 'USurvivalGameUserSettings::FSR2' has a wrong offset!");
static_assert(offsetof(USurvivalGameUserSettings, CustomShadowQuality) == 0x0001B4, "Member 'USurvivalGameUserSettings::CustomShadowQuality' has a wrong offset!");

// Class Survival.SurvivalGameViewportClient
// 0x0020 (0x03D0 - 0x03B0)
class USurvivalGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_3B0[0x20];                                     // 0x03B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalGameViewportClient">();
	}
	static class USurvivalGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivalGameViewportClient>();
	}
};
static_assert(alignof(USurvivalGameViewportClient) == 0x000008, "Wrong alignment on USurvivalGameViewportClient");
static_assert(sizeof(USurvivalGameViewportClient) == 0x0003D0, "Wrong size on USurvivalGameViewportClient");

// Class Survival.SurvivalPlayerController
// 0x0010 (0x0878 - 0x0868)
class ASurvivalPlayerController : public ABE_PlayerController
{
public:
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ClientLeftTheGame;                                 // 0x0870(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamID;                                            // 0x0871(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_872[0x6];                                      // 0x0872(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetEngineConfigBoolValue(class FName ConfigSection, class FName ConfigKey);
	static float GetEngineConfigFloatValue(class FName ConfigSection, class FName ConfigKey);
	static float GetFGearSendrate();

	void ClientWasKickedCustom(const class FText& KickReason);
	void GoTo(float LocationX, float LocationY, float LocationZ);
	void HandleClientWasKicked(const class FText& KickReason);
	void Rotate(float RotationX, float RotationY, float RotationZ);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalPlayerController">();
	}
	static class ASurvivalPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASurvivalPlayerController>();
	}
};
static_assert(alignof(ASurvivalPlayerController) == 0x000008, "Wrong alignment on ASurvivalPlayerController");
static_assert(sizeof(ASurvivalPlayerController) == 0x000878, "Wrong size on ASurvivalPlayerController");
static_assert(offsetof(ASurvivalPlayerController, ClientLeftTheGame) == 0x000870, "Member 'ASurvivalPlayerController::ClientLeftTheGame' has a wrong offset!");
static_assert(offsetof(ASurvivalPlayerController, TeamID) == 0x000871, "Member 'ASurvivalPlayerController::TeamID' has a wrong offset!");

// Class Survival.SurvivalStatSystem
// 0x0090 (0x00C0 - 0x0030)
class USurvivalStatSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Report(const class FString& EventId);
	void Report2(const class FString& EventId, const TMap<class FString, class FString>& Properties);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivalStatSystem">();
	}
	static class USurvivalStatSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivalStatSystem>();
	}
};
static_assert(alignof(USurvivalStatSystem) == 0x000008, "Wrong alignment on USurvivalStatSystem");
static_assert(sizeof(USurvivalStatSystem) == 0x0000C0, "Wrong size on USurvivalStatSystem");

// Class Survival.TDBJsonObject
// 0x0010 (0x0038 - 0x0028)
class UTDBJsonObject final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTDBJsonObject* ConstructJsonObject(class UObject* WorldContextObject);

	bool DecodeJson(const class FString& JsonString);
	TArray<class UTDBJsonValue*> GetArrayField(const class FString& FieldName);
	TArray<bool> GetBoolArrayField(const class FString& FieldName);
	TArray<class FString> GetFieldNames();
	TArray<float> GetNumberArrayField(const class FString& FieldName);
	TArray<class UTDBJsonObject*> GetObjectArrayField(const class FString& FieldName);
	TArray<class FString> GetStringArrayField(const class FString& FieldName);
	void MergeJsonObject(class UTDBJsonObject* InJsonObject, bool Overwrite);
	void RemoveField(const class FString& FieldName);
	void Reset();
	void SetArrayField(const class FString& FieldName, const TArray<class UTDBJsonValue*>& InArray);
	void SetBoolArrayField(const class FString& FieldName, const TArray<bool>& BoolArray);
	void SetBoolField(const class FString& FieldName, bool InValue);
	void SetField(const class FString& FieldName, class UTDBJsonValue* JsonValue);
	void SetFieldNull(const class FString& FieldName);
	void SetNumberArrayField(const class FString& FieldName, const TArray<float>& NumberArray);
	void SetNumberField(const class FString& FieldName, float Number);
	void SetObjectArrayField(const class FString& FieldName, const TArray<class UTDBJsonObject*>& ObjectArray);
	void SetObjectField(const class FString& FieldName, class UTDBJsonObject* JsonObject);
	void SetStringArrayField(const class FString& FieldName, const TArray<class FString>& StringArray);
	void SetStringField(const class FString& FieldName, const class FString& StringValue);

	class FString EncodeJson() const;
	bool GetBoolField(const class FString& FieldName) const;
	class UTDBJsonValue* GetField(const class FString& FieldName) const;
	float GetNumberField(const class FString& FieldName) const;
	class UTDBJsonObject* GetObjectField(const class FString& FieldName) const;
	class FString GetStringField(const class FString& FieldName) const;
	bool HasField(const class FString& FieldName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDBJsonObject">();
	}
	static class UTDBJsonObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTDBJsonObject>();
	}
};
static_assert(alignof(UTDBJsonObject) == 0x000008, "Wrong alignment on UTDBJsonObject");
static_assert(sizeof(UTDBJsonObject) == 0x000038, "Wrong size on UTDBJsonObject");

// Class Survival.TDBJsonValue
// 0x0010 (0x0038 - 0x0028)
class UTDBJsonValue final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTDBJsonValue* ConstructJsonValueArray(class UObject* WorldContextObject, const TArray<class UTDBJsonValue*>& InArray);
	static class UTDBJsonValue* ConstructJsonValueBool(class UObject* WorldContextObject, bool InValue);
	static class UTDBJsonValue* ConstructJsonValueNumber(class UObject* WorldContextObject, float Number);
	static class UTDBJsonValue* ConstructJsonValueObject(class UObject* WorldContextObject, class UTDBJsonObject* JsonObject);
	static class UTDBJsonValue* ConstructJsonValueString(class UObject* WorldContextObject, const class FString& StringValue);

	class UTDBJsonObject* AsObject();

	TArray<class UTDBJsonValue*> AsArray() const;
	bool AsBool() const;
	float AsNumber() const;
	class FString AsString() const;
	EPFJson GetType() const;
	class FString GetTypeString() const;
	bool IsNull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDBJsonValue">();
	}
	static class UTDBJsonValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTDBJsonValue>();
	}
};
static_assert(alignof(UTDBJsonValue) == 0x000008, "Wrong alignment on UTDBJsonValue");
static_assert(sizeof(UTDBJsonValue) == 0x000038, "Wrong size on UTDBJsonValue");

// Class Survival.TDB_CustomSkyLight
// 0x0000 (0x0290 - 0x0290)
class ATDB_CustomSkyLight : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDB_CustomSkyLight">();
	}
	static class ATDB_CustomSkyLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDB_CustomSkyLight>();
	}
};
static_assert(alignof(ATDB_CustomSkyLight) == 0x000008, "Wrong alignment on ATDB_CustomSkyLight");
static_assert(sizeof(ATDB_CustomSkyLight) == 0x000290, "Wrong size on ATDB_CustomSkyLight");

// Class Survival.TDB_Deer
// 0x0000 (0x0630 - 0x0630)
class ATDB_Deer : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDB_Deer">();
	}
	static class ATDB_Deer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDB_Deer>();
	}
};
static_assert(alignof(ATDB_Deer) == 0x000010, "Wrong alignment on ATDB_Deer");
static_assert(sizeof(ATDB_Deer) == 0x000630, "Wrong size on ATDB_Deer");

// Class Survival.TDB_LevelInspectorSubsystem
// 0x0000 (0x0030 - 0x0030)
class UTDB_LevelInspectorSubsystem final : public UGameInstanceSubsystem
{
public:
	bool GetCurrentLevelLoadedFull(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDB_LevelInspectorSubsystem">();
	}
	static class UTDB_LevelInspectorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTDB_LevelInspectorSubsystem>();
	}
};
static_assert(alignof(UTDB_LevelInspectorSubsystem) == 0x000008, "Wrong alignment on UTDB_LevelInspectorSubsystem");
static_assert(sizeof(UTDB_LevelInspectorSubsystem) == 0x000030, "Wrong size on UTDB_LevelInspectorSubsystem");

// Class Survival.TDB_LittleZombie
// 0x0000 (0x0630 - 0x0630)
class ATDB_LittleZombie final : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDB_LittleZombie">();
	}
	static class ATDB_LittleZombie* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDB_LittleZombie>();
	}
};
static_assert(alignof(ATDB_LittleZombie) == 0x000010, "Wrong alignment on ATDB_LittleZombie");
static_assert(sizeof(ATDB_LittleZombie) == 0x000630, "Wrong size on ATDB_LittleZombie");

// Class Survival.TDB_Weapon
// 0x0000 (0x0290 - 0x0290)
class ATDB_Weapon : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDB_Weapon">();
	}
	static class ATDB_Weapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDB_Weapon>();
	}
};
static_assert(alignof(ATDB_Weapon) == 0x000008, "Wrong alignment on ATDB_Weapon");
static_assert(sizeof(ATDB_Weapon) == 0x000290, "Wrong size on ATDB_Weapon");

// Class Survival.TDB_WeaponPlaceHolder
// 0x0000 (0x0290 - 0x0290)
class ATDB_WeaponPlaceHolder : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDB_WeaponPlaceHolder">();
	}
	static class ATDB_WeaponPlaceHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDB_WeaponPlaceHolder>();
	}
};
static_assert(alignof(ATDB_WeaponPlaceHolder) == 0x000008, "Wrong alignment on ATDB_WeaponPlaceHolder");
static_assert(sizeof(ATDB_WeaponPlaceHolder) == 0x000290, "Wrong size on ATDB_WeaponPlaceHolder");

// Class Survival.SettingsWidgetBase
// 0x0008 (0x0288 - 0x0280)
class USettingsWidgetBase : public UUserWidget
{
public:
	class UUserWidget*                            PreviousMenuLink;                                  // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseSubmenu(bool Focused);
	class USurvivalGameUserSettings* GetSurvivalUserSettings();
	void OpenSubmenu(class USettingsWidgetBase* WidgetToShow, int32 ZOrder, bool Focused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsWidgetBase">();
	}
	static class USettingsWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsWidgetBase>();
	}
};
static_assert(alignof(USettingsWidgetBase) == 0x000008, "Wrong alignment on USettingsWidgetBase");
static_assert(sizeof(USettingsWidgetBase) == 0x000288, "Wrong size on USettingsWidgetBase");
static_assert(offsetof(USettingsWidgetBase, PreviousMenuLink) == 0x000280, "Member 'USettingsWidgetBase::PreviousMenuLink' has a wrong offset!");

// Class Survival.ControlsSettingsWidget
// 0x0000 (0x0288 - 0x0288)
class UControlsSettingsWidget : public USettingsWidgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlsSettingsWidget">();
	}
	static class UControlsSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlsSettingsWidget>();
	}
};
static_assert(alignof(UControlsSettingsWidget) == 0x000008, "Wrong alignment on UControlsSettingsWidget");
static_assert(sizeof(UControlsSettingsWidget) == 0x000288, "Wrong size on UControlsSettingsWidget");

// Class Survival.ControlValue
// 0x0000 (0x0288 - 0x0288)
class UControlValue : public USettingsWidgetBase
{
public:
	void RemapActionMapping(const struct FInputActionKeyMapping& InKeyMappingToFind, const struct FInputActionKeyMapping& InKeyMappingToReplace, const bool bForceRebuildKeymaps);
	void RemapAxisMapping(const struct FInputAxisKeyMapping& InKeyMappingToFind, const struct FInputAxisKeyMapping& InKeyMappingToReplace, const bool bForceRebuildKeymaps);
	void SaveKeyMappingsWithoutSort();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlValue">();
	}
	static class UControlValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlValue>();
	}
};
static_assert(alignof(UControlValue) == 0x000008, "Wrong alignment on UControlValue");
static_assert(sizeof(UControlValue) == 0x000288, "Wrong size on UControlValue");

// Class Survival.GammaWidget
// 0x0000 (0x0288 - 0x0288)
class UGammaWidget final : public USettingsWidgetBase
{
public:
	void OnGammaChanged(float NewValue);

	float OnGetGamma() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GammaWidget">();
	}
	static class UGammaWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGammaWidget>();
	}
};
static_assert(alignof(UGammaWidget) == 0x000008, "Wrong alignment on UGammaWidget");
static_assert(sizeof(UGammaWidget) == 0x000288, "Wrong size on UGammaWidget");

// Class Survival.UtilitiesLibrary
// 0x0000 (0x0028 - 0x0028)
class UUtilitiesLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeCollisionOnPhysicsBody(class USkeletalMeshComponent* SkeletalMesh, class FName BoneName, ECollisionEnabled CollisionType);
	static bool ExportRenderTargetCube(class UTextureRenderTargetCube* RenderTargetCube, const class FString& FilePath);
	static void SetAllBodiesBelowLinearAndAngularDamping(class USkeletalMeshComponent* InTarget, class FName InBoneName, float InLinear, float InAngular);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilitiesLibrary">();
	}
	static class UUtilitiesLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilitiesLibrary>();
	}
};
static_assert(alignof(UUtilitiesLibrary) == 0x000008, "Wrong alignment on UUtilitiesLibrary");
static_assert(sizeof(UUtilitiesLibrary) == 0x000028, "Wrong size on UUtilitiesLibrary");

// Class Survival.VideoSettingsWidget
// 0x0000 (0x0288 - 0x0288)
class UVideoSettingsWidget : public USettingsWidgetBase
{
public:
	bool GetGPUAMD();
	class FString GetGPUBrandName();
	TArray<struct FDisplayDeviceAndSupportedResolutions> GetMonitorInfos();
	bool GetNVidia();
	void SetMonitorByIndex(int32 Param_Index);

	TArray<class FString> GetMonitors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VideoSettingsWidget">();
	}
	static class UVideoSettingsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVideoSettingsWidget>();
	}
};
static_assert(alignof(UVideoSettingsWidget) == 0x000008, "Wrong alignment on UVideoSettingsWidget");
static_assert(sizeof(UVideoSettingsWidget) == 0x000288, "Wrong size on UVideoSettingsWidget");

// Class Survival.Weapon
// 0x0000 (0x0290 - 0x0290)
class AWeapon final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Weapon">();
	}
	static class AWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeapon>();
	}
};
static_assert(alignof(AWeapon) == 0x000008, "Wrong alignment on AWeapon");
static_assert(sizeof(AWeapon) == 0x000290, "Wrong size on AWeapon");

// Class Survival.WeaponAnimAsset
// 0x05D0 (0x0600 - 0x0030)
class UWeaponAnimAsset final : public UDataAsset
{
public:
	struct FWepAnimInfo                           Poses;                                             // 0x0030(0x0240)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reload;                                            // 0x0270(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            EquipRight;                                        // 0x02A0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            EquipLeft;                                         // 0x02D0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            UnequipRight;                                      // 0x0300(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            UnequipLeft;                                       // 0x0330(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            CrouchEquipRight;                                  // 0x0360(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            CrouchEquipLeft;                                   // 0x0390(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            CrouchUnequipRight;                                // 0x03C0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            CrouchUnequipLeft;                                 // 0x03F0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ReadyEquipRight;                                   // 0x0420(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ReadyEquipLeft;                                    // 0x0450(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ReadyUnequipRight;                                 // 0x0480(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ReadyUnequipLeft;                                  // 0x04B0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AimFire;                                           // 0x04E0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            HipFire;                                           // 0x0510(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            CrouchHipFire;                                     // 0x0540(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWepPhasedReload                       IdlePhasedReload;                                  // 0x0570(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimAsset">();
	}
	static class UWeaponAnimAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimAsset>();
	}
};
static_assert(alignof(UWeaponAnimAsset) == 0x000008, "Wrong alignment on UWeaponAnimAsset");
static_assert(sizeof(UWeaponAnimAsset) == 0x000600, "Wrong size on UWeaponAnimAsset");
static_assert(offsetof(UWeaponAnimAsset, Poses) == 0x000030, "Member 'UWeaponAnimAsset::Poses' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, Reload) == 0x000270, "Member 'UWeaponAnimAsset::Reload' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, EquipRight) == 0x0002A0, "Member 'UWeaponAnimAsset::EquipRight' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, EquipLeft) == 0x0002D0, "Member 'UWeaponAnimAsset::EquipLeft' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, UnequipRight) == 0x000300, "Member 'UWeaponAnimAsset::UnequipRight' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, UnequipLeft) == 0x000330, "Member 'UWeaponAnimAsset::UnequipLeft' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, CrouchEquipRight) == 0x000360, "Member 'UWeaponAnimAsset::CrouchEquipRight' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, CrouchEquipLeft) == 0x000390, "Member 'UWeaponAnimAsset::CrouchEquipLeft' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, CrouchUnequipRight) == 0x0003C0, "Member 'UWeaponAnimAsset::CrouchUnequipRight' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, CrouchUnequipLeft) == 0x0003F0, "Member 'UWeaponAnimAsset::CrouchUnequipLeft' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, ReadyEquipRight) == 0x000420, "Member 'UWeaponAnimAsset::ReadyEquipRight' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, ReadyEquipLeft) == 0x000450, "Member 'UWeaponAnimAsset::ReadyEquipLeft' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, ReadyUnequipRight) == 0x000480, "Member 'UWeaponAnimAsset::ReadyUnequipRight' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, ReadyUnequipLeft) == 0x0004B0, "Member 'UWeaponAnimAsset::ReadyUnequipLeft' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, AimFire) == 0x0004E0, "Member 'UWeaponAnimAsset::AimFire' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, HipFire) == 0x000510, "Member 'UWeaponAnimAsset::HipFire' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, CrouchHipFire) == 0x000540, "Member 'UWeaponAnimAsset::CrouchHipFire' has a wrong offset!");
static_assert(offsetof(UWeaponAnimAsset, IdlePhasedReload) == 0x000570, "Member 'UWeaponAnimAsset::IdlePhasedReload' has a wrong offset!");

// Class Survival.WeaponIndependetFOVSkMeshComp
// 0x0010 (0x0FE0 - 0x0FD0)
class UWeaponIndependetFOVSkMeshComp : public USkeletalMeshComponent
{
public:
	float                                         DesiredHorizontalFov;                              // 0x0FD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponFOV;                                         // 0x0FD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOwnFOV;                                         // 0x0FD8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD9[0x7];                                      // 0x0FD9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponIndependetFOVSkMeshComp">();
	}
	static class UWeaponIndependetFOVSkMeshComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponIndependetFOVSkMeshComp>();
	}
};
static_assert(alignof(UWeaponIndependetFOVSkMeshComp) == 0x000010, "Wrong alignment on UWeaponIndependetFOVSkMeshComp");
static_assert(sizeof(UWeaponIndependetFOVSkMeshComp) == 0x000FE0, "Wrong size on UWeaponIndependetFOVSkMeshComp");
static_assert(offsetof(UWeaponIndependetFOVSkMeshComp, DesiredHorizontalFov) == 0x000FD0, "Member 'UWeaponIndependetFOVSkMeshComp::DesiredHorizontalFov' has a wrong offset!");
static_assert(offsetof(UWeaponIndependetFOVSkMeshComp, WeaponFOV) == 0x000FD4, "Member 'UWeaponIndependetFOVSkMeshComp::WeaponFOV' has a wrong offset!");
static_assert(offsetof(UWeaponIndependetFOVSkMeshComp, UseOwnFOV) == 0x000FD8, "Member 'UWeaponIndependetFOVSkMeshComp::UseOwnFOV' has a wrong offset!");

// Class Survival.ZombieAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UZombieAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAnimInstance">();
	}
	static class UZombieAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAnimInstance>();
	}
};
static_assert(alignof(UZombieAnimInstance) == 0x000010, "Wrong alignment on UZombieAnimInstance");
static_assert(sizeof(UZombieAnimInstance) == 0x000350, "Wrong size on UZombieAnimInstance");

// Class Survival.ZombiePawn
// 0x0048 (0x0360 - 0x0318)
class AZombiePawn final : public APawn
{
public:
	FMulticastInlineDelegateProperty_             OnSetTargetActorParent;                            // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UPawnMovementComponent*                 MovementComponent;                                 // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Head;                                              // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Body;                                              // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Feet;                                              // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZombieAnimType                               ZombieAnimType;                                    // 0x0358(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAgressive;                                        // 0x0359(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDamaged;                                          // 0x035A(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZombieType                                   ZombieType;                                        // 0x035B(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAgressive();
	bool GetBackToIdle();
	bool GetDamaged();
	EZombieAnimType GetZombieAnimType();
	EZombieType GetZombieType();
	void SetAgressive(bool NewValue);
	void SetBackToIdle(bool NewValue);
	void SetDamaged(bool NewValue);
	void SetZombieAnimType(EZombieAnimType NewZombieAnimType);
	void SetZombieType(EZombieType NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiePawn">();
	}
	static class AZombiePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombiePawn>();
	}
};
static_assert(alignof(AZombiePawn) == 0x000008, "Wrong alignment on AZombiePawn");
static_assert(sizeof(AZombiePawn) == 0x000360, "Wrong size on AZombiePawn");
static_assert(offsetof(AZombiePawn, OnSetTargetActorParent) == 0x000318, "Member 'AZombiePawn::OnSetTargetActorParent' has a wrong offset!");
static_assert(offsetof(AZombiePawn, MovementComponent) == 0x000328, "Member 'AZombiePawn::MovementComponent' has a wrong offset!");
static_assert(offsetof(AZombiePawn, Mesh) == 0x000330, "Member 'AZombiePawn::Mesh' has a wrong offset!");
static_assert(offsetof(AZombiePawn, Head) == 0x000338, "Member 'AZombiePawn::Head' has a wrong offset!");
static_assert(offsetof(AZombiePawn, Body) == 0x000340, "Member 'AZombiePawn::Body' has a wrong offset!");
static_assert(offsetof(AZombiePawn, Feet) == 0x000348, "Member 'AZombiePawn::Feet' has a wrong offset!");
static_assert(offsetof(AZombiePawn, CapsuleComponent) == 0x000350, "Member 'AZombiePawn::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AZombiePawn, ZombieAnimType) == 0x000358, "Member 'AZombiePawn::ZombieAnimType' has a wrong offset!");
static_assert(offsetof(AZombiePawn, bAgressive) == 0x000359, "Member 'AZombiePawn::bAgressive' has a wrong offset!");
static_assert(offsetof(AZombiePawn, bDamaged) == 0x00035A, "Member 'AZombiePawn::bDamaged' has a wrong offset!");
static_assert(offsetof(AZombiePawn, ZombieType) == 0x00035B, "Member 'AZombiePawn::ZombieType' has a wrong offset!");

}

