#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JSIContainer

#include "Basic.hpp"

#include "ContainerType_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "RarityColors_structs.hpp"
#include "JSItemType_structs.hpp"
#include "InputCore_structs.hpp"
#include "DefaultItemInfo_structs.hpp"
#include "E_ShopContainer_structs.hpp"
#include "SlotRarity_structs.hpp"


namespace SDK
{

// WidgetBlueprintGeneratedClass JSIContainer.JSIContainer_C
// 0x0488 (0x0708 - 0x0280)
class UJSIContainer_C final : public UUserWidget
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0280(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UCanvasPanel*                           CellContainer;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UBorder*                                ContainerBorder;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UImage*                                 Image_Highlighter;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UOverlay*                               MainOverlay;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class USizeBox*                               SizeBox_Title;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UTextBlock*                             TextBlock_ContainerText;                           // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UUniformGridPanel*                      Ungrid_Content;                                    // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UUniformGridPanel*                      Ungrid_SlotShadows;                                // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	bool                                          Initialized;                                       // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContainerID;                                       // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	EContainerType                                ContainerType;                                     // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfRows;                                      // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         NumberOfColumns;                                   // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJSI_Slot_C*>                    WSlots;                                            // 0x02E0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	struct FVector2D                              SlotSize;                                          // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FMargin                                SlotPadding;                                       // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	struct FSlateColor                            SlotOnHoverColor;                                  // 0x0310(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	struct FSlateColor                            DragHighlightColor;                                // 0x0324(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	struct FSlateColor                            InvalidDragHighlightColor;                         // 0x0338(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRarityColors>                  RarityColors;                                      // 0x0350(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	class UPaperSprite*                           SlotImage;                                         // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FSlateColor                            ImageTint;                                         // 0x0368(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	int32                                         CurrentSlotIndex;                                  // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UUniformGridSlot*>               GridSlots;                                         // 0x0380(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	struct FLinearColor                           ContainerTint;                                     // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	TMap<int32, class UJSI_Slot_C*>               GridSlotsDic;                                      // 0x03A0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UJSI_Slot_C*>                    HighlightedSlots;                                  // 0x03F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          CanDrop_;                                          // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FromXLoc;                                          // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         FromYLoc;                                          // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSI_Slot_C*                            SlotRecH;                                          // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              MouseLocH;                                         // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             DataSource;                                        // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	TArray<class UJSI_Slot_C*>                    ArrayOfItems;                                      // 0x0430(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<EJSItemType>                           SupportedItemTypes;                                // 0x0440(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	FMulticastInlineDelegateProperty_             ItemsCombined;                                     // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             DropInfo_ContainerToContainer;                     // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             DropInfo_OnItemEquippedChange;                     // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<int32>                                 OnlySupportTheseIDs;                               // 0x0480(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	TArray<int32>                                 DoNotSupportTheseIDs;                              // 0x0490(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	struct FKey                                   RotateKey;                                         // 0x04A0(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         DropToSlot;                                        // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   SplitKey;                                          // 0x04C0(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             DropInfo_SplitPerformed;                           // 0x04D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Drop_ItemOverItem;                                 // 0x04E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	EDragPivot                                    DragBehaviour;                                     // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_4F9[0x7];                                      // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxWeight;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HideItemOnDrag_;                                   // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDefaultItemInfo>               AddDefaultItems;                                   // 0x0510(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference, ExposeOnSpawn)
	bool                                          AllowDrag;                                         // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowMovingItemsOnDrop;                            // 0x0521(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowOpeningContainers;                            // 0x0522(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          HandleContainerToContainerDrop;                    // 0x0523(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_524[0x4];                                      // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Drop_ContainerOnContainerUnhandled;                // 0x0528(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          ReceiveAllUnhandledEvent;                          // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          ShowPrices;                                        // 0x0539(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_53A[0x6];                                      // 0x053A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSlotMouseButtonDown;                             // 0x0540(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnSlotDoubleClick;                                 // 0x0550(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          DragRotated_;                                      // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DroppedSlotRotated_;                               // 0x0561(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_562[0x6];                                      // 0x0562(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ContainerName;                                     // 0x0568(0x0018)(Edit, BlueprintVisible)
	bool                                          AllowDropToContainer;                              // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowDropToGround;                                 // 0x0581(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_582[0x6];                                      // 0x0582(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemSlotOrRotationChanged;                       // 0x0588(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UJSI_Slot_C*                            SlotMother;                                        // 0x0598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnItemSplitRequest;                                // 0x05A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          AutoPerformSplit;                                  // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemStackRequest;                                // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          AutoPerformStack;                                  // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStackCountChanged;                               // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         ParentID;                                          // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJSItemType>                           SortHighlightedTypes;                              // 0x05E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          AllowBlindAddItemToContainer_;                     // 0x05F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsPartSpecialContainer;                            // 0x05F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Loot;                                              // 0x05FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5FB[0x5];                                      // 0x05FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ItemsDataTable;                                    // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMouseIn;                                         // 0x0608(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_609[0x7];                                      // 0x0609(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDragDropOperation*                     Operation;                                         // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          Equip;                                             // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_619[0x7];                                      // 0x0619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSI_Slot_C*                            ActiveSlot;                                        // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          IsShop;                                            // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0630(0x0018)(Edit, BlueprintVisible)
	class UJSIContainer_C*                        CurrentItemMoveContainer;                          // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UJSI_Slot_C*                            SelectedSlot;                                      // 0x0650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnContainerUpdate;                                 // 0x0658(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class ASurvivalPlayer_C*                      SurvivalPlayerRef;                                 // 0x0668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             EventSelectItem;                                   // 0x0670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             Unselect;                                          // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             DragStart;                                         // 0x0690(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             DragEnd;                                           // 0x06A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<class UJSI_Slot_C*>                    EmptySlots;                                        // 0x06B0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	class UWidget*                                Navigation_LeftWidget;                             // 0x06C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              CustomSizeSlot;                                    // 0x06C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          Toggle_Price_Shop;                                 // 0x06D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_6D9[0x7];                                      // 0x06D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Set_Custom_Translation;                            // 0x06E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	E_ShopContainer                               SetShopContainer;                                  // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6F1[0x7];                                      // 0x06F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ItemsDispatcher;                                   // 0x06F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)

public:
	void AddMultipleInventoryItems(TArray<int32>& ItemIDs, TArray<int32>* NotAdded);
	void AddNewInventoryItem(class FName ItemId, int32 Count, int32 ToSlot, bool Rotated_, bool TryRotated_, bool TryToStack_, const struct FFItemInfo& CustomInfo, bool* Added, int32* SlotIndex, struct FFItemInfo* ItemInfo, class UJSI_Slot_C** SlotItemRef, int32* StackRemainder);
	void AddNewInventoryItem_CustomVector(class FName ItemId, int32 Count, int32 ToSlot, const struct FVector2D& SlotVector, const struct FVector2D& OriginalSize, const struct FFItemInfo& CustomInfo, bool* Added, int32* SlotIndex, struct FFItemInfo* ItemInfo, class UJSI_Slot_C** SlotItemRef);
	void AddNewItem(int32 ToSlot, TSoftObjectPtr<class UObject> Image, const struct FVector2D& SlotVector, ESlotRarity Rarity, const struct FFItemInfo& ItemInfo, bool SetVector, bool* Added, int32* AddedToSlot, struct FFItemInfo* Info, class UJSI_Slot_C** SlotItemRef);
	void AddSortHighlightedTypes(const TArray<EJSItemType>& Types);
	struct FVector2D CalculateSize(const struct FVector2D& SlotVector);
	struct FVector2D CalculateSizeCustom(const struct FVector2D& SlotVector, const struct FVector2D& CSlotSize);
	void CalculateWeight(double* Weight);
	void Call_Container_On_Container(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool Param_DragRotated_, bool TryRotated_);
	void CancelHighlights(bool Drop);
	void CancelHlight();
	void CanItAllFitIn(TArray<class UJSI_Slot_C*>& Param_ArrayOfItems, bool* CanFit_);
	void CanResize_(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Result, TArray<class UJSI_Slot_C*>* HostingSlotsArray, TArray<class UJSI_Slot_C*>* FreedHostingSlotsArray);
	void CanStack_(class UJSIContainer_C* Container, const struct FFItemInfo& ItemInfo, bool* Canstack);
	void CanStackSingleSlot_(const struct FFItemInfo& Info, bool* Sucess, class UJSI_Slot_C** ItemRef);
	void ChangeItemCount(class UJSI_Slot_C* ItemRef, int32 NewCount, bool* Changed_);
	void ChangeItemImage(class UJSI_Slot_C* ItemRef, class UPaperSprite* NewTexture, bool* Changed_);
	void ChangeItemRarity(class UJSI_Slot_C* ItemRef, ESlotRarity NewRarity, bool* Changed_);
	void ChangeItemsInteract(bool Interact_);
	void CheckAvailableItemsByName(class FName Param_Name, int32 Count, bool* Found);
	void CheckCanRemoveBackpack(class UJSIContainer_C* Pocket, bool* NotAllowed1);
	bool CheckEquippedSlots(class UJSIContainer_C* FromContainer, class UMPInGameInventory_C* Inventory);
	void CheckIsEmptySlot(int32 Param_Index, const struct FVector2D& SlotDimension, bool* NotEmpty);
	void CheckIsEmptySlots(TArray<class UJSI_Slot_C*>& Array, bool* Return);
	void CheckItemBeforeEquip(const struct FFItemInfo& ItemInfo, struct FFItemInfo* Result);
	void CheckMoneyMoveToCase(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, bool* Allow);
	void CheckTutorial(class UJSI_Slot_C* Param_Slot, class UJSIContainer_C* OnContainer, class UJSIContainer_C* FromContainer, bool* Locked, bool* IsCase);
	void ClearContainer();
	void ClearContainerOccupation();
	void ClearData();
	void ClearSelection();
	void CombineItemRequest(class UJSIContainer_C* FromContainer, class UJSI_Slot_C* SlotRec, class UJSI_Slot_C* SlotDropped, bool TriggerEventDispatcher_);
	void Construct();
	bool DeleteItemInfo();
	bool DeleteSelectItem();
	void Destruct();
	void DragEnd__DelegateSignature();
	void DragStart__DelegateSignature();
	void Drop_ContainerOnContainerUnhandled__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool Rotated_, bool RightMouseButton);
	void Drop_ItemOverItem__DelegateSignature(class UJSI_Slot_C* ItemReceiver, class UJSI_Slot_C* ItemDropped, class UJSIContainer_C* ItemReceiverContainer, class UJSIContainer_C* ItemDroppedContainer);
	void DropInfo_ContainerToContainer__DelegateSignature(class UJSIContainer_C* From, class UJSIContainer_C* To, class UJSI_Slot_C* FromSlotRef, class UJSI_Slot_C* ToSlotRef, bool ToEmptySlot_, bool MovedAll_);
	void DropInfo_OnItemEquippedChange__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, bool Equipped_, bool ToPockets_);
	void DropInfo_SplitPerformed__DelegateSignature(class UJSI_Slot_C* SourceSlotRef, class UJSI_Slot_C* NewSplitSlotRef, class UJSIContainer_C* ContainerSource, class UJSIContainer_C* ContainerReceiver, int32 SplitAmount, int32 AmountRemaining);
	void Equip_Item(class FName ItemId, const struct FVector2D& SlotVector, const struct FFItemInfo& CustomInfo, class UJSIContainer_C* SlotContainer, bool TriggerEquippedEvent_, bool* Equipped, class UJSI_Slot_C** SlotItemRef);
	void EventSelectItem__DelegateSignature(class UJSI_Slot_C* Item, class UJSIContainer_C* Container);
	void ExecuteUbergraph_JSIContainer(int32 EntryPoint);
	void FlipSlotDim(const struct FVector2D& SlotVector, struct FVector2D* Flipped);
	void GenerateEmptySlots(int32 MinRows, int32 MinColumns);
	void GenerateEmptySlots__OnDrag_(class UJSI_Slot_C* JSISlot, bool OnlyReset);
	void Get_Max_YDimension(class UJSIContainer_C* Container, int32* SlotsCount);
	void GetColumnRowBySlotIndex(int32 SlotIndex, int32* Column, int32* Row);
	int32 GetContainerCapacity();
	void GetContainerHierarchy(TArray<class UJSIContainer_C*>* Containers);
	void GetContainerName(class FText* Param_ContainerName);
	void GetCountFreeSlots(int32* Value);
	void GetDropSlotWithOffset(int32 SizeX, int32 SizeY, int32 SlotIndex, int32 PivotIndex, int32* SlotIndex1, bool* Result);
	void GetEmptySlot(const struct FVector2D& SlotVector, bool OccupyAfterCheck, int32* SlotIndex, bool* Found_);
	void GetEquippedItemRef(bool* Found_, class UJSI_Slot_C** ItemRef);
	void GetInventoryItemsByID(int32 ItemId, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetInventoryItemsByName(class FName ItemName, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetInventoryItemsByType(EJSItemType Type, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetItemBySlotIndex(int32 SlotIndex, bool* Found, class UJSI_Slot_C** Item);
	void GetItemByUniqueID(int32 UniqueId, bool* Found, class UJSI_Slot_C** Item);
	void GetItemsByRarity(ESlotRarity Rarity, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	int32 GetItemsCount();
	int32 GetLength();
	void GetLowestSlotIndex(TArray<class UJSI_Slot_C*>& Array, int32* MinIndex);
	int32 GetMaxCountSlots();
	void GetNumberOfFreeSlots(int32* Num);
	void GetPaddingBySlotIndex(int32 SlotIndex, const struct FVector2D& SlotVector, struct FMargin* Param_Padding, int32* Conumn, int32* Row);
	void GetRootContainerRef(bool ExcludeEquipTo, class UJSIContainer_C** ContainerRef);
	void GetSelecetItemName(class FText* Param_Name);
	void GetSelectItemInfo(struct FFItemInfo* ItemInfo);
	void GetSlotIndex(int32* Result);
	int32 GetSlotIndexByColumnRow(int32 Column, int32 Row);
	void GetSlotMotherUID(bool ReturnContainerID_IfInvalid_, int32* UDID);
	void GetWeight(double* Return);
	void HandleContainerOnContainer(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool DraggedRotated_, bool TryRotated_, bool* Handled_);
	void HighlightItemsByType(TArray<EJSItemType>& Types);
	void HighlightSlots(int32 SlotIndex, const struct FVector2D& SlotVector, const struct FVector2D& MouseLoc, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* SlotRecRef, bool Rotated_, bool Supported_, int32 PivotIndex);
	void Hightlight_DragMove(int32 SlotIndex, class UJSI_Slot_C* DragSlotRef, class UJSI_Slot_C* SlotRec, bool Rotated_, int32 PivotIndex);
	void Initialize(bool Design_);
	bool IsEquipped_();
	void IsSupportedID_(int32 ID, bool* Supported);
	void IsSupportedType_(TArray<EJSItemType>& Param_SupportedItemTypes, const EJSItemType& Type, int32 ItemId, bool* Supported_);
	void Items_Filter_Surv();
	void Items_FilterDupl();
	void ItemsCombined__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotReceiver, class UJSI_Slot_C* SlotDropped, bool SlotDroppedRemoved_);
	void ItemsDispatcher__DelegateSignature();
	void ItemsFilterEvent();
	void ItemsFilterEventDelayer();
	void MakeCell();
	void MoveHighlighter(class UJSI_Slot_C* ItemSlot, TArray<class UJSI_Slot_C*>& Highlighted, bool Candrop, bool Rotated);
	void MoveItemToContainer(class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemRef, int32 Count, int32 ToSlot, bool Rotated_, bool* Moved_);
	void MoveItemToIndexByItemRef(class UJSI_Slot_C* ItemRef, int32 ToIndex, bool Rotate_, bool* Moved_);
	void MoveItemToIndexBySlotIndex(int32 ItemSlotIndex, int32 ToIndex, bool Rotate_, bool* Moved_);
	void NavigationChange(EUINavigation Direaction);
	void OnContainerUpdate__DelegateSignature();
	void OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Param_Operation);
	void OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Param_Operation);
	bool OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Param_Operation);
	void OnItemSlotOrRotationChanged__DelegateSignature(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, int32 NewIndex, bool Rotated);
	void OnItemSplitRequest__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemSource, int32 ToSlotIndex, int32 TotalAmount, int32 SplitAmount);
	void OnItemStackRequest__DelegateSignature(class UJSI_Slot_C* DroppedItem, class UJSI_Slot_C* ReceiverItem);
	struct FEventReply OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);
	void OnMouseLeave(const struct FPointerEvent& MouseEvent);
	void OnPlayerDeath();
	void OnSlotDoubleClick__DelegateSignature(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button);
	void OnSlotMouseButtonDown__DelegateSignature(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button);
	void OnStackCountChanged__DelegateSignature(class UJSI_Slot_C* ItemRef, int32 NewCount);
	void PerfromDrop(int32 SlotIndex, const struct FVector2D& SlotVector, class UJSI_Slot_C* SlotRef, bool Rotated_, bool* Moved);
	void PreConstruct(bool IsDesignTime);
	void ReMinusInit(int32 Columns, int32 Rows);
	void ReMinusSortHighlightItems();
	void RecalculateHighlighretSize(double SingleSlotSizeX, double SingleSlotSizeY, const struct FVector2D& Dimention, double DistanceBetweenSlots, struct FVector2D* Size);
	void RecalculateHighlighterDim(TArray<class UJSI_Slot_C*>& Slots, struct FVector2D* Dimention);
	void RecalculateHighlitherPosition(TArray<class UJSI_Slot_C*>& Slots, bool Rotated, struct FVector2D* Position);
	void RemoveInventoryItemByRef(class UJSI_Slot_C* SlotRef, bool* Removed);
	void RemoveItemByUniqueID(int32 ID, bool* Sucess);
	void RemoveSortHighlightedTypes(TArray<EJSItemType>& Types);
	void ResizeItem(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Resized_);
	void SelectRotation(class UJSI_Slot_C* ItemRef, bool DroppedRotated_, bool* Rotated);
	void SelectSlot(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button);
	void SetBGColorOfDragWidget(class UDragDropOperation* Target, bool Candrop, bool Leave);
	void SetHightlightBrush(const struct FVector2D& Dim, bool Candrop, class UPaperSprite** BG_Sprite1);
	void SetNavigationWidget_Left(class UWidget* NavigationWidget);
	bool SomeFunctionBool();
	void StopDrag();
	void StopDragAndDrop();
	void TakeAllItems();
	void Tick(const struct FGeometry& MyGeometry, float InDeltaTime);
	void UnequipItem(bool TriggerUnequippedEvent_, bool* Unequipped, class UJSI_Slot_C** SlotRef);
	void Unselect__DelegateSignature();
	void UpdateCountByUniqueID(int32 ID, int32 NewCount, bool* Sucess);
	void UpdateTitle();

	void GetDropOffset(int32 SizeX, int32 SizeY, int32 PivotIndex, int32* X_Offset, int32* Y_Offset) const;
	void GetIndexBySlotLocation(int32 Row, int32 Col, int32* SlotIndex, bool* Result) const;
	void GetSlotLocationByIndex(int32 SlotIndex_Loc, int32* ColumnIndex_, int32* RowIndex_) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"JSIContainer_C">();
	}
	static class UJSIContainer_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJSIContainer_C>();
	}
};
static_assert(alignof(UJSIContainer_C) == 0x000008, "Wrong alignment on UJSIContainer_C");
static_assert(sizeof(UJSIContainer_C) == 0x000708, "Wrong size on UJSIContainer_C");
static_assert(offsetof(UJSIContainer_C, UberGraphFrame) == 0x000280, "Member 'UJSIContainer_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CellContainer) == 0x000288, "Member 'UJSIContainer_C::CellContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerBorder) == 0x000290, "Member 'UJSIContainer_C::ContainerBorder' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Image_Highlighter) == 0x000298, "Member 'UJSIContainer_C::Image_Highlighter' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MainOverlay) == 0x0002A0, "Member 'UJSIContainer_C::MainOverlay' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SizeBox_Title) == 0x0002A8, "Member 'UJSIContainer_C::SizeBox_Title' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, TextBlock_ContainerText) == 0x0002B0, "Member 'UJSIContainer_C::TextBlock_ContainerText' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Ungrid_Content) == 0x0002B8, "Member 'UJSIContainer_C::Ungrid_Content' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Ungrid_SlotShadows) == 0x0002C0, "Member 'UJSIContainer_C::Ungrid_SlotShadows' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Initialized) == 0x0002C8, "Member 'UJSIContainer_C::Initialized' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerID) == 0x0002CC, "Member 'UJSIContainer_C::ContainerID' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerType) == 0x0002D0, "Member 'UJSIContainer_C::ContainerType' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, NumberOfRows) == 0x0002D4, "Member 'UJSIContainer_C::NumberOfRows' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, NumberOfColumns) == 0x0002D8, "Member 'UJSIContainer_C::NumberOfColumns' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, WSlots) == 0x0002E0, "Member 'UJSIContainer_C::WSlots' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotSize) == 0x0002F0, "Member 'UJSIContainer_C::SlotSize' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotPadding) == 0x000300, "Member 'UJSIContainer_C::SlotPadding' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotOnHoverColor) == 0x000310, "Member 'UJSIContainer_C::SlotOnHoverColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragHighlightColor) == 0x000324, "Member 'UJSIContainer_C::DragHighlightColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, InvalidDragHighlightColor) == 0x000338, "Member 'UJSIContainer_C::InvalidDragHighlightColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, RarityColors) == 0x000350, "Member 'UJSIContainer_C::RarityColors' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotImage) == 0x000360, "Member 'UJSIContainer_C::SlotImage' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ImageTint) == 0x000368, "Member 'UJSIContainer_C::ImageTint' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CurrentSlotIndex) == 0x00037C, "Member 'UJSIContainer_C::CurrentSlotIndex' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, GridSlots) == 0x000380, "Member 'UJSIContainer_C::GridSlots' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerTint) == 0x000390, "Member 'UJSIContainer_C::ContainerTint' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, GridSlotsDic) == 0x0003A0, "Member 'UJSIContainer_C::GridSlotsDic' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HighlightedSlots) == 0x0003F0, "Member 'UJSIContainer_C::HighlightedSlots' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CanDrop_) == 0x000400, "Member 'UJSIContainer_C::CanDrop_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, FromXLoc) == 0x000404, "Member 'UJSIContainer_C::FromXLoc' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, FromYLoc) == 0x000408, "Member 'UJSIContainer_C::FromYLoc' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotRecH) == 0x000410, "Member 'UJSIContainer_C::SlotRecH' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MouseLocH) == 0x000418, "Member 'UJSIContainer_C::MouseLocH' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DataSource) == 0x000428, "Member 'UJSIContainer_C::DataSource' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ArrayOfItems) == 0x000430, "Member 'UJSIContainer_C::ArrayOfItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SupportedItemTypes) == 0x000440, "Member 'UJSIContainer_C::SupportedItemTypes' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ItemsCombined) == 0x000450, "Member 'UJSIContainer_C::ItemsCombined' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropInfo_ContainerToContainer) == 0x000460, "Member 'UJSIContainer_C::DropInfo_ContainerToContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropInfo_OnItemEquippedChange) == 0x000470, "Member 'UJSIContainer_C::DropInfo_OnItemEquippedChange' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnlySupportTheseIDs) == 0x000480, "Member 'UJSIContainer_C::OnlySupportTheseIDs' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DoNotSupportTheseIDs) == 0x000490, "Member 'UJSIContainer_C::DoNotSupportTheseIDs' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, RotateKey) == 0x0004A0, "Member 'UJSIContainer_C::RotateKey' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropToSlot) == 0x0004B8, "Member 'UJSIContainer_C::DropToSlot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SplitKey) == 0x0004C0, "Member 'UJSIContainer_C::SplitKey' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropInfo_SplitPerformed) == 0x0004D8, "Member 'UJSIContainer_C::DropInfo_SplitPerformed' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Drop_ItemOverItem) == 0x0004E8, "Member 'UJSIContainer_C::Drop_ItemOverItem' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragBehaviour) == 0x0004F8, "Member 'UJSIContainer_C::DragBehaviour' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MaxWeight) == 0x000500, "Member 'UJSIContainer_C::MaxWeight' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HideItemOnDrag_) == 0x000508, "Member 'UJSIContainer_C::HideItemOnDrag_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AddDefaultItems) == 0x000510, "Member 'UJSIContainer_C::AddDefaultItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowDrag) == 0x000520, "Member 'UJSIContainer_C::AllowDrag' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowMovingItemsOnDrop) == 0x000521, "Member 'UJSIContainer_C::AllowMovingItemsOnDrop' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowOpeningContainers) == 0x000522, "Member 'UJSIContainer_C::AllowOpeningContainers' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HandleContainerToContainerDrop) == 0x000523, "Member 'UJSIContainer_C::HandleContainerToContainerDrop' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Drop_ContainerOnContainerUnhandled) == 0x000528, "Member 'UJSIContainer_C::Drop_ContainerOnContainerUnhandled' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ReceiveAllUnhandledEvent) == 0x000538, "Member 'UJSIContainer_C::ReceiveAllUnhandledEvent' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ShowPrices) == 0x000539, "Member 'UJSIContainer_C::ShowPrices' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnSlotMouseButtonDown) == 0x000540, "Member 'UJSIContainer_C::OnSlotMouseButtonDown' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnSlotDoubleClick) == 0x000550, "Member 'UJSIContainer_C::OnSlotDoubleClick' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragRotated_) == 0x000560, "Member 'UJSIContainer_C::DragRotated_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DroppedSlotRotated_) == 0x000561, "Member 'UJSIContainer_C::DroppedSlotRotated_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerName) == 0x000568, "Member 'UJSIContainer_C::ContainerName' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowDropToContainer) == 0x000580, "Member 'UJSIContainer_C::AllowDropToContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowDropToGround) == 0x000581, "Member 'UJSIContainer_C::AllowDropToGround' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemSlotOrRotationChanged) == 0x000588, "Member 'UJSIContainer_C::OnItemSlotOrRotationChanged' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotMother) == 0x000598, "Member 'UJSIContainer_C::SlotMother' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemSplitRequest) == 0x0005A0, "Member 'UJSIContainer_C::OnItemSplitRequest' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AutoPerformSplit) == 0x0005B0, "Member 'UJSIContainer_C::AutoPerformSplit' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemStackRequest) == 0x0005B8, "Member 'UJSIContainer_C::OnItemStackRequest' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AutoPerformStack) == 0x0005C8, "Member 'UJSIContainer_C::AutoPerformStack' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnStackCountChanged) == 0x0005D0, "Member 'UJSIContainer_C::OnStackCountChanged' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ParentID) == 0x0005E0, "Member 'UJSIContainer_C::ParentID' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SortHighlightedTypes) == 0x0005E8, "Member 'UJSIContainer_C::SortHighlightedTypes' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowBlindAddItemToContainer_) == 0x0005F8, "Member 'UJSIContainer_C::AllowBlindAddItemToContainer_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsPartSpecialContainer) == 0x0005F9, "Member 'UJSIContainer_C::IsPartSpecialContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Loot) == 0x0005FA, "Member 'UJSIContainer_C::Loot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ItemsDataTable) == 0x000600, "Member 'UJSIContainer_C::ItemsDataTable' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsMouseIn) == 0x000608, "Member 'UJSIContainer_C::IsMouseIn' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Operation) == 0x000610, "Member 'UJSIContainer_C::Operation' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Equip) == 0x000618, "Member 'UJSIContainer_C::Equip' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ActiveSlot) == 0x000620, "Member 'UJSIContainer_C::ActiveSlot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsShop) == 0x000628, "Member 'UJSIContainer_C::IsShop' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, TitleText) == 0x000630, "Member 'UJSIContainer_C::TitleText' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CurrentItemMoveContainer) == 0x000648, "Member 'UJSIContainer_C::CurrentItemMoveContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SelectedSlot) == 0x000650, "Member 'UJSIContainer_C::SelectedSlot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnContainerUpdate) == 0x000658, "Member 'UJSIContainer_C::OnContainerUpdate' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SurvivalPlayerRef) == 0x000668, "Member 'UJSIContainer_C::SurvivalPlayerRef' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, EventSelectItem) == 0x000670, "Member 'UJSIContainer_C::EventSelectItem' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Unselect) == 0x000680, "Member 'UJSIContainer_C::Unselect' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragStart) == 0x000690, "Member 'UJSIContainer_C::DragStart' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragEnd) == 0x0006A0, "Member 'UJSIContainer_C::DragEnd' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, EmptySlots) == 0x0006B0, "Member 'UJSIContainer_C::EmptySlots' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Navigation_LeftWidget) == 0x0006C0, "Member 'UJSIContainer_C::Navigation_LeftWidget' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CustomSizeSlot) == 0x0006C8, "Member 'UJSIContainer_C::CustomSizeSlot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Toggle_Price_Shop) == 0x0006D8, "Member 'UJSIContainer_C::Toggle_Price_Shop' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Set_Custom_Translation) == 0x0006E0, "Member 'UJSIContainer_C::Set_Custom_Translation' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SetShopContainer) == 0x0006F0, "Member 'UJSIContainer_C::SetShopContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ItemsDispatcher) == 0x0006F8, "Member 'UJSIContainer_C::ItemsDispatcher' has a wrong offset!");

}

