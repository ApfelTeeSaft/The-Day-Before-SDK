#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Weapon

#include "Basic.hpp"

#include "BP_Weapon_classes.hpp"
#include "BP_Weapon_parameters.hpp"


namespace SDK
{

// Function BP_Weapon.BP_Weapon_C.AddAmmoToInventory
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsForCurrentWeapon                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewAmmoCount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AmmoNameForOtherWeapon                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AmmoCountForOtherWeapon                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::AddAmmoToInventory(bool bIsForCurrentWeapon, int32 NewAmmoCount, class FName AmmoNameForOtherWeapon, int32 AmmoCountForOtherWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "AddAmmoToInventory");

	Params::BP_Weapon_C_AddAmmoToInventory Parms{};

	Parms.bIsForCurrentWeapon = bIsForCurrentWeapon;
	Parms.NewAmmoCount = NewAmmoCount;
	Parms.AmmoNameForOtherWeapon = AmmoNameForOtherWeapon;
	Parms.AmmoCountForOtherWeapon = AmmoCountForOtherWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.AimEvent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Aim                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::AimEvent(bool Aim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "AimEvent");

	Params::BP_Weapon_C_AimEvent Parms{};

	Parms.Aim = Aim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.AimPunch
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::AimPunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "AimPunch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.AimPunchTimeline__FinishedFunc
// (BlueprintEvent)

void ABP_Weapon_C::AimPunchTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "AimPunchTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.AimPunchTimeline__UpdateFunc
// (BlueprintEvent)

void ABP_Weapon_C::AimPunchTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "AimPunchTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.AutoFireSound
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Start                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::AutoFireSound(bool Start)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "AutoFireSound");

	Params::BP_Weapon_C_AutoFireSound Parms{};

	Parms.Start = Start;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.BoltActionResume
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::BoltActionResume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BoltActionResume");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.BoltActionStop
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::BoltActionStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BoltActionStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.BrokenSound
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::BrokenSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BrokenSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.BrokenSoundMulticast
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::BrokenSoundMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BrokenSoundMulticast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.BrokenSoundServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::BrokenSoundServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BrokenSoundServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.BulletTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FBPS_DamageInfo>          OutHit                                                 (Parm, OutParm, ContainsInstancedReference)
// bool                                    GetHit                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::BulletTrace(TArray<struct FBPS_DamageInfo>* OutHit, bool* GetHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BulletTrace");

	Params::BP_Weapon_C_BulletTrace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (GetHit != nullptr)
		*GetHit = Parms.GetHit;
}


// Function BP_Weapon.BP_Weapon_C.BurstShot
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::BurstShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "BurstShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.CalculateDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// double                                  ResultDamage                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CalculateDamage(class APawn* Pawn, const struct FHitResult& Hit, double* ResultDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CalculateDamage");

	Params::BP_Weapon_C_CalculateDamage Parms{};

	Parms.Pawn = Pawn;
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (ResultDamage != nullptr)
		*ResultDamage = Parms.ResultDamage;
}


// Function BP_Weapon.BP_Weapon_C.CalculateSubtrahendForPhased
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Subtrahend                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CalculateSubtrahendForPhased(double* Subtrahend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CalculateSubtrahendForPhased");

	Params::BP_Weapon_C_CalculateSubtrahendForPhased Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Subtrahend != nullptr)
		*Subtrahend = Parms.Subtrahend;
}


// Function BP_Weapon.BP_Weapon_C.CallAmmoUpdate
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::CallAmmoUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CallAmmoUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.CallRecoilPowerChange
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Param_RecoilPower                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CallRecoilPowerChange(double Param_RecoilPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CallRecoilPowerChange");

	Params::BP_Weapon_C_CallRecoilPowerChange Parms{};

	Parms.Param_RecoilPower = Param_RecoilPower;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.CameraRecoilTimeline__FinishedFunc
// (BlueprintEvent)

void ABP_Weapon_C::CameraRecoilTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CameraRecoilTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.CameraRecoilTimeline__UpdateFunc
// (BlueprintEvent)

void ABP_Weapon_C::CameraRecoilTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CameraRecoilTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.CanShoot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bIsCan                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CanShoot(bool* bIsCan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CanShoot");

	Params::BP_Weapon_C_CanShoot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bIsCan != nullptr)
		*bIsCan = Parms.bIsCan;
}


// Function BP_Weapon.BP_Weapon_C.ChangeAmmoClass
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ChangeAmmoClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ChangeAmmoClass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ChangeFireMode
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ChangeFireMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ChangeFireMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.CheckAvailabilityAmmoType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsPlayerChangeAmmoType                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIsChangedAmmoType                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EBPE_AmmoClass                          SettedAmmoClass                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EBPE_AmmoType                           SettedAmmoType                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CheckAvailabilityAmmoType(bool bIsPlayerChangeAmmoType, bool* bIsChangedAmmoType, EBPE_AmmoClass* SettedAmmoClass, EBPE_AmmoType* SettedAmmoType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CheckAvailabilityAmmoType");

	Params::BP_Weapon_C_CheckAvailabilityAmmoType Parms{};

	Parms.bIsPlayerChangeAmmoType = bIsPlayerChangeAmmoType;

	UObject::ProcessEvent(Func, &Parms);

	if (bIsChangedAmmoType != nullptr)
		*bIsChangedAmmoType = Parms.bIsChangedAmmoType;

	if (SettedAmmoClass != nullptr)
		*SettedAmmoClass = Parms.SettedAmmoClass;

	if (SettedAmmoType != nullptr)
		*SettedAmmoType = Parms.SettedAmmoType;
}


// Function BP_Weapon.BP_Weapon_C.CHeckDamageDuplicate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FBPS_DamageInfo>          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    CanAdd                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CHeckDamageDuplicate(class UObject* A, TArray<struct FBPS_DamageInfo>& Array, bool* CanAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CHeckDamageDuplicate");

	Params::BP_Weapon_C_CHeckDamageDuplicate Parms{};

	Parms.A = A;
	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (CanAdd != nullptr)
		*CanAdd = Parms.CanAdd;
}


// Function BP_Weapon.BP_Weapon_C.CheckForDrySound
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::CheckForDrySound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CheckForDrySound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.CheckWeapEffector
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HipFire                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::CheckWeapEffector(bool HipFire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "CheckWeapEffector");

	Params::BP_Weapon_C_CheckWeapEffector Parms{};

	Parms.HipFire = HipFire;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.DecreaseDurability
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::DecreaseDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "DecreaseDurability");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.DelayDecalSpawn
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               DecalMaterial                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_Weapon_C::DelayDecalSpawn(const struct FVector& Location, const struct FVector& Forward, class UMaterialInterface* DecalMaterial, const TArray<class AActor*>& ActorsToIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "DelayDecalSpawn");

	Params::BP_Weapon_C_DelayDecalSpawn Parms{};

	Parms.Location = std::move(Location);
	Parms.Forward = std::move(Forward);
	Parms.DecalMaterial = DecalMaterial;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.DisableHipFire
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::DisableHipFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "DisableHipFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.DropItemServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFItemInfo                       F_DroppedItemInfo                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void ABP_Weapon_C::DropItemServer(struct FFItemInfo& F_DroppedItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "DropItemServer");

	Params::BP_Weapon_C_DropItemServer Parms{};

	Parms.F_DroppedItemInfo = std::move(F_DroppedItemInfo);

	UObject::ProcessEvent(Func, &Parms);

	F_DroppedItemInfo = std::move(Parms.F_DroppedItemInfo);
}


// Function BP_Weapon.BP_Weapon_C.EnableCollision
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Activation                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::EnableCollision(bool Activation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "EnableCollision");

	Params::BP_Weapon_C_EnableCollision Parms{};

	Parms.Activation = Activation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.EndReload
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::EndReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "EndReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.EngagedInFight
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::EngagedInFight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "EngagedInFight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ExecuteUbergraph_BP_Weapon
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::ExecuteUbergraph_BP_Weapon(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ExecuteUbergraph_BP_Weapon");

	Params::BP_Weapon_C_ExecuteUbergraph_BP_Weapon Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.FakeFire
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FBPS_DamageInfo>          HitInfo                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Param_Fire                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::FakeFire(const TArray<struct FBPS_DamageInfo>& HitInfo, bool Param_Fire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "FakeFire");

	Params::BP_Weapon_C_FakeFire Parms{};

	Parms.HitInfo = std::move(HitInfo);
	Parms.Param_Fire = Param_Fire;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.FastReload
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::FastReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "FastReload");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.FightEnded
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::FightEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "FightEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.FindBestTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               Results                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FHitResult                       Target                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Finded                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::FindBestTarget(TArray<struct FHitResult>& Results, struct FHitResult* Target, bool* Finded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "FindBestTarget");

	Params::BP_Weapon_C_FindBestTarget Parms{};

	Parms.Results = std::move(Results);

	UObject::ProcessEvent(Func, &Parms);

	Results = std::move(Parms.Results);

	if (Target != nullptr)
		*Target = std::move(Parms.Target);

	if (Finded != nullptr)
		*Finded = Parms.Finded;
}


// Function BP_Weapon.BP_Weapon_C.FindTargetForMelee
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Finded                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::FindTargetForMelee(class AActor** Target, bool* Finded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "FindTargetForMelee");

	Params::BP_Weapon_C_FindTargetForMelee Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;

	if (Finded != nullptr)
		*Finded = Parms.Finded;
}


// Function BP_Weapon.BP_Weapon_C.fire
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    _PulledTrigger                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::Fire(bool _PulledTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "fire");

	Params::BP_Weapon_C_Fire Parms{};

	Parms._PulledTrigger = _PulledTrigger;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.FireRatioTimer
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::FireRatioTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "FireRatioTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ForceReloadStop
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ForceReloadStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ForceReloadStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.GetDecalMaterial
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInstanceDynamic*         DynMat                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetDecalMaterial(EPhysicalSurface SurfaceType, class UMaterialInstanceDynamic** DynMat, struct FVector* Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetDecalMaterial");

	Params::BP_Weapon_C_GetDecalMaterial Parms{};

	Parms.SurfaceType = SurfaceType;

	UObject::ProcessEvent(Func, &Parms);

	if (DynMat != nullptr)
		*DynMat = Parms.DynMat;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);
}


// Function BP_Weapon.BP_Weapon_C.GetMeleeWeaponMontage
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Output                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetMeleeWeaponMontage(class UAnimMontage** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetMeleeWeaponMontage");

	Params::BP_Weapon_C_GetMeleeWeaponMontage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function BP_Weapon.BP_Weapon_C.GetPhasedReloadBegin2
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     NewParam                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetPhasedReloadBegin2(class UAnimMontage** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetPhasedReloadBegin2");

	Params::BP_Weapon_C_GetPhasedReloadBegin2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Weapon.BP_Weapon_C.GetPhasedReloadEnd2
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     NewParam                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetPhasedReloadEnd2(class UAnimMontage** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetPhasedReloadEnd2");

	Params::BP_Weapon_C_GetPhasedReloadEnd2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Weapon.BP_Weapon_C.GetPhasedReloadLoop2
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     NewParam                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetPhasedReloadLoop2(class UAnimMontage** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetPhasedReloadLoop2");

	Params::BP_Weapon_C_GetPhasedReloadLoop2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Weapon.BP_Weapon_C.GetProjectileNiagara
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UNiagaraSystem*                   Output                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetProjectileNiagara(class UNiagaraSystem** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetProjectileNiagara");

	Params::BP_Weapon_C_GetProjectileNiagara Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function BP_Weapon.BP_Weapon_C.GetReloadCharAnim2
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     NewParam                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetReloadCharAnim2(class UAnimMontage** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetReloadCharAnim2");

	Params::BP_Weapon_C_GetReloadCharAnim2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Weapon.BP_Weapon_C.GetReloadPlayRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetReloadPlayRate(double* PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetReloadPlayRate");

	Params::BP_Weapon_C_GetReloadPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;
}


// Function BP_Weapon.BP_Weapon_C.GetWeaponShotMontage
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimMontage*                     NewParam                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::GetWeaponShotMontage(class UAnimMontage** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "GetWeaponShotMontage");

	Params::BP_Weapon_C_GetWeaponShotMontage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Weapon.BP_Weapon_C.HeadshotXP
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::HeadshotXP(class AActor* HitActor, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HeadshotXP");

	Params::BP_Weapon_C_HeadshotXP Parms{};

	Parms.HitActor = HitActor;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.HipFireCamera
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    On_                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::HipFireCamera(bool On_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HipFireCamera");

	Params::BP_Weapon_C_HipFireCamera Parms{};

	Parms.On_ = On_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.HipFireCameraDisable
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::HipFireCameraDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HipFireCameraDisable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.HipFireServer
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_HipFireMode                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::HipFireServer(bool Param_HipFireMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HipFireServer");

	Params::BP_Weapon_C_HipFireServer Parms{};

	Parms.Param_HipFireMode = Param_HipFireMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.HitHandling
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          ImpactPoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ImpactNormal                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        SurfaceType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::HitHandling(const struct FHitResult& Hit, struct FVector* ImpactPoint, struct FVector* ImpactNormal, EPhysicalSurface* SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HitHandling");

	Params::BP_Weapon_C_HitHandling Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (ImpactPoint != nullptr)
		*ImpactPoint = std::move(Parms.ImpactPoint);

	if (ImpactNormal != nullptr)
		*ImpactNormal = std::move(Parms.ImpactNormal);

	if (SurfaceType != nullptr)
		*SurfaceType = Parms.SurfaceType;
}


// Function BP_Weapon.BP_Weapon_C.HitSimplify
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FS_SimplifiedHitInfo             S_SimplifiedHitInfo                                    (Parm, OutParm, ZeroConstructor, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)

void ABP_Weapon_C::HitSimplify(const struct FHitResult& Hit, struct FS_SimplifiedHitInfo* S_SimplifiedHitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HitSimplify");

	Params::BP_Weapon_C_HitSimplify Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (S_SimplifiedHitInfo != nullptr)
		*S_SimplifiedHitInfo = std::move(Parms.S_SimplifiedHitInfo);
}


// Function BP_Weapon.BP_Weapon_C.HitTraceFromCenter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       BlockingHit                                            (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    WasHit                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LocationWithoutHit                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::HitTraceFromCenter(struct FHitResult* BlockingHit, bool* WasHit, struct FVector* LocationWithoutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "HitTraceFromCenter");

	Params::BP_Weapon_C_HitTraceFromCenter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BlockingHit != nullptr)
		*BlockingHit = std::move(Parms.BlockingHit);

	if (WasHit != nullptr)
		*WasHit = Parms.WasHit;

	if (LocationWithoutHit != nullptr)
		*LocationWithoutHit = std::move(Parms.LocationWithoutHit);
}


// Function BP_Weapon.BP_Weapon_C.InitDurability
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::InitDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "InitDurability");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.InitValues
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::InitValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "InitValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.InterpRecoil__FinishedFunc
// (BlueprintEvent)

void ABP_Weapon_C::InterpRecoil__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "InterpRecoil__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.InterpRecoil__UpdateFunc
// (BlueprintEvent)

void ABP_Weapon_C::InterpRecoil__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "InterpRecoil__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.Kostyl
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::Kostyl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "Kostyl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.LoadAnimMontage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UAnimMontage>      Soft                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UAnimMontage*                     AnimMontage                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::LoadAnimMontage(TSoftObjectPtr<class UAnimMontage> Soft, class UAnimMontage** AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "LoadAnimMontage");

	Params::BP_Weapon_C_LoadAnimMontage Parms{};

	Parms.Soft = Soft;

	UObject::ProcessEvent(Func, &Parms);

	if (AnimMontage != nullptr)
		*AnimMontage = Parms.AnimMontage;
}


// Function BP_Weapon.BP_Weapon_C.MakeProjectileShot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       BlockingHit                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    WasHit                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::MakeProjectileShot(const struct FHitResult& BlockingHit, bool WasHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MakeProjectileShot");

	Params::BP_Weapon_C_MakeProjectileShot Parms{};

	Parms.BlockingHit = std::move(BlockingHit);
	Parms.WasHit = WasHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.MeleeAttack
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::MeleeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MeleeAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.MeleeSkipAnimTime__FinishedFunc
// (BlueprintEvent)

void ABP_Weapon_C::MeleeSkipAnimTime__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MeleeSkipAnimTime__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.MeleeSkipAnimTime__UpdateFunc
// (BlueprintEvent)

void ABP_Weapon_C::MeleeSkipAnimTime__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MeleeSkipAnimTime__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.MeleeTargetRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

struct FRotator ABP_Weapon_C::MeleeTargetRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MeleeTargetRotation");

	Params::BP_Weapon_C_MeleeTargetRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Weapon.BP_Weapon_C.MeleeTrace
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::MeleeTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MeleeTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.MultiShotgunReloadAnim
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    BulletIn                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::MultiShotgunReloadAnim(bool BulletIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "MultiShotgunReloadAnim");

	Params::BP_Weapon_C_MultiShotgunReloadAnim Parms{};

	Parms.BulletIn = BulletIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnBlendOut_0FB3F6564A0CD0C952EFF8BFC06DC154
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnBlendOut_0FB3F6564A0CD0C952EFF8BFC06DC154(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnBlendOut_0FB3F6564A0CD0C952EFF8BFC06DC154");

	Params::BP_Weapon_C_OnBlendOut_0FB3F6564A0CD0C952EFF8BFC06DC154 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnBlendOut_642915F049FF687BCEAB758975C4E4D2
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnBlendOut_642915F049FF687BCEAB758975C4E4D2(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnBlendOut_642915F049FF687BCEAB758975C4E4D2");

	Params::BP_Weapon_C_OnBlendOut_642915F049FF687BCEAB758975C4E4D2 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnBlendOut_A24E11344E6A4662725E59913D420242
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnBlendOut_A24E11344E6A4662725E59913D420242(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnBlendOut_A24E11344E6A4662725E59913D420242");

	Params::BP_Weapon_C_OnBlendOut_A24E11344E6A4662725E59913D420242 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnCompleted_0FB3F6564A0CD0C952EFF8BFC06DC154
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnCompleted_0FB3F6564A0CD0C952EFF8BFC06DC154(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnCompleted_0FB3F6564A0CD0C952EFF8BFC06DC154");

	Params::BP_Weapon_C_OnCompleted_0FB3F6564A0CD0C952EFF8BFC06DC154 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnCompleted_642915F049FF687BCEAB758975C4E4D2
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnCompleted_642915F049FF687BCEAB758975C4E4D2(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnCompleted_642915F049FF687BCEAB758975C4E4D2");

	Params::BP_Weapon_C_OnCompleted_642915F049FF687BCEAB758975C4E4D2 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnCompleted_A24E11344E6A4662725E59913D420242
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnCompleted_A24E11344E6A4662725E59913D420242(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnCompleted_A24E11344E6A4662725E59913D420242");

	Params::BP_Weapon_C_OnCompleted_A24E11344E6A4662725E59913D420242 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnInterrupted_0FB3F6564A0CD0C952EFF8BFC06DC154
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnInterrupted_0FB3F6564A0CD0C952EFF8BFC06DC154(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnInterrupted_0FB3F6564A0CD0C952EFF8BFC06DC154");

	Params::BP_Weapon_C_OnInterrupted_0FB3F6564A0CD0C952EFF8BFC06DC154 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnInterrupted_642915F049FF687BCEAB758975C4E4D2
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnInterrupted_642915F049FF687BCEAB758975C4E4D2(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnInterrupted_642915F049FF687BCEAB758975C4E4D2");

	Params::BP_Weapon_C_OnInterrupted_642915F049FF687BCEAB758975C4E4D2 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnInterrupted_A24E11344E6A4662725E59913D420242
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnInterrupted_A24E11344E6A4662725E59913D420242(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnInterrupted_A24E11344E6A4662725E59913D420242");

	Params::BP_Weapon_C_OnInterrupted_A24E11344E6A4662725E59913D420242 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnLoaded_A077CC734AC02F2F596C3D9FB33E2BBF
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnLoaded_A077CC734AC02F2F596C3D9FB33E2BBF(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnLoaded_A077CC734AC02F2F596C3D9FB33E2BBF");

	Params::BP_Weapon_C_OnLoaded_A077CC734AC02F2F596C3D9FB33E2BBF Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnNotifyBegin_0FB3F6564A0CD0C952EFF8BFC06DC154
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnNotifyBegin_0FB3F6564A0CD0C952EFF8BFC06DC154(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnNotifyBegin_0FB3F6564A0CD0C952EFF8BFC06DC154");

	Params::BP_Weapon_C_OnNotifyBegin_0FB3F6564A0CD0C952EFF8BFC06DC154 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnNotifyBegin_642915F049FF687BCEAB758975C4E4D2
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnNotifyBegin_642915F049FF687BCEAB758975C4E4D2(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnNotifyBegin_642915F049FF687BCEAB758975C4E4D2");

	Params::BP_Weapon_C_OnNotifyBegin_642915F049FF687BCEAB758975C4E4D2 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnNotifyBegin_A24E11344E6A4662725E59913D420242
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnNotifyBegin_A24E11344E6A4662725E59913D420242(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnNotifyBegin_A24E11344E6A4662725E59913D420242");

	Params::BP_Weapon_C_OnNotifyBegin_A24E11344E6A4662725E59913D420242 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnNotifyEnd_0FB3F6564A0CD0C952EFF8BFC06DC154
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnNotifyEnd_0FB3F6564A0CD0C952EFF8BFC06DC154(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnNotifyEnd_0FB3F6564A0CD0C952EFF8BFC06DC154");

	Params::BP_Weapon_C_OnNotifyEnd_0FB3F6564A0CD0C952EFF8BFC06DC154 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnNotifyEnd_642915F049FF687BCEAB758975C4E4D2
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnNotifyEnd_642915F049FF687BCEAB758975C4E4D2(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnNotifyEnd_642915F049FF687BCEAB758975C4E4D2");

	Params::BP_Weapon_C_OnNotifyEnd_642915F049FF687BCEAB758975C4E4D2 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnNotifyEnd_A24E11344E6A4662725E59913D420242
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::OnNotifyEnd_A24E11344E6A4662725E59913D420242(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnNotifyEnd_A24E11344E6A4662725E59913D420242");

	Params::BP_Weapon_C_OnNotifyEnd_A24E11344E6A4662725E59913D420242 Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.OnRep_bIsPlayEndRoundsSound
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::OnRep_bIsPlayEndRoundsSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnRep_bIsPlayEndRoundsSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.OnWeaponInited
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::OnWeaponInited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "OnWeaponInited");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.PlayAimFire
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::PlayAimFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlayAimFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.PlayEndRoundsEffectMulticast
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::PlayEndRoundsEffectMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlayEndRoundsEffectMulticast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.PlayHipFire
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::PlayHipFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlayHipFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.PlayHitParticle
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPhysicalSurface                        Enumerator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          InputPin                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USceneComponent*                  Component_To_Attach                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FName                             bone                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Hit_Normal                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoSound                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::PlayHitParticle(EPhysicalSurface Enumerator, const struct FVector& InputPin, const struct FVector& Forward, class USceneComponent* Component_To_Attach, class FName bone, class AActor* HitActor, const struct FVector& Hit_Normal, bool NoSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlayHitParticle");

	Params::BP_Weapon_C_PlayHitParticle Parms{};

	Parms.Enumerator = Enumerator;
	Parms.InputPin = std::move(InputPin);
	Parms.Forward = std::move(Forward);
	Parms.Component_To_Attach = Component_To_Attach;
	Parms.bone = bone;
	Parms.HitActor = HitActor;
	Parms.Hit_Normal = std::move(Hit_Normal);
	Parms.NoSound = NoSound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.PlayMeleeMontage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::PlayMeleeMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlayMeleeMontage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.PlayShootShake
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FBPS_WeaponData                  BPS_WeaponData                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void ABP_Weapon_C::PlayShootShake(const struct FBPS_WeaponData& BPS_WeaponData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlayShootShake");

	Params::BP_Weapon_C_PlayShootShake Parms{};

	Parms.BPS_WeaponData = std::move(BPS_WeaponData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.PlaySmoothShootShake
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Start                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::PlaySmoothShootShake(bool Start)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PlaySmoothShootShake");

	Params::BP_Weapon_C_PlaySmoothShootShake Parms{};

	Parms.Start = Start;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.PreciseHitPoint
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          HitPoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::PreciseHitPoint(struct FVector* HitPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PreciseHitPoint");

	Params::BP_Weapon_C_PreciseHitPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HitPoint != nullptr)
		*HitPoint = std::move(Parms.HitPoint);
}


// Function BP_Weapon.BP_Weapon_C.PredictHitTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       BlockingHit                                            (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    WasHit                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::PredictHitTrace(struct FHitResult* BlockingHit, bool* WasHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "PredictHitTrace");

	Params::BP_Weapon_C_PredictHitTrace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BlockingHit != nullptr)
		*BlockingHit = std::move(Parms.BlockingHit);

	if (WasHit != nullptr)
		*WasHit = Parms.WasHit;
}


// Function BP_Weapon.BP_Weapon_C.ProjectileTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       BlockingHit                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    WasHit                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LocationWithoutHit                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShowDecal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Weapon_C::ProjectileTrace(const struct FHitResult& BlockingHit, bool WasHit, const struct FVector& LocationWithoutHit, struct FHitResult* OutHit, bool* ShowDecal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ProjectileTrace");

	Params::BP_Weapon_C_ProjectileTrace Parms{};

	Parms.BlockingHit = std::move(BlockingHit);
	Parms.WasHit = WasHit;
	Parms.LocationWithoutHit = std::move(LocationWithoutHit);

	UObject::ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (ShowDecal != nullptr)
		*ShowDecal = Parms.ShowDecal;

	return Parms.ReturnValue;
}


// Function BP_Weapon.BP_Weapon_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Weapon_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ReceiveTick");

	Params::BP_Weapon_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.Recoil Compensation for Train
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_Weapon_C::Recoil_Compensation_for_Train()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "Recoil Compensation for Train");

	Params::BP_Weapon_C_Recoil_Compensation_for_Train Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Weapon.BP_Weapon_C.RecoilAdd
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::RecoilAdd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilAdd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.RecoilCamera
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::RecoilCamera(bool Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilCamera");

	Params::BP_Weapon_C_RecoilCamera Parms{};

	Parms.Forward = Forward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.RecoilFirstPerson
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Pitch                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Yaw                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::RecoilFirstPerson(double Pitch, double Yaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilFirstPerson");

	Params::BP_Weapon_C_RecoilFirstPerson Parms{};

	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.RecoilLerpTimeline__FinishedFunc
// (BlueprintEvent)

void ABP_Weapon_C::RecoilLerpTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilLerpTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.RecoilLerpTimeline__UpdateFunc
// (BlueprintEvent)

void ABP_Weapon_C::RecoilLerpTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilLerpTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.RecoilStabilize
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::RecoilStabilize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilStabilize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.RecoilStableRoutine__FinishedFunc
// (BlueprintEvent)

void ABP_Weapon_C::RecoilStableRoutine__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilStableRoutine__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.RecoilStableRoutine__UpdateFunc
// (BlueprintEvent)

void ABP_Weapon_C::RecoilStableRoutine__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "RecoilStableRoutine__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ReInitVars
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFItemInfo                       ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void ABP_Weapon_C::ReInitVars(const struct FFItemInfo& ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ReInitVars");

	Params::BP_Weapon_C_ReInitVars Parms{};

	Parms.ItemInfo = std::move(ItemInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.Reload
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsFastReloadMulti                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::Reload(bool bIsFastReloadMulti)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "Reload");

	Params::BP_Weapon_C_Reload Parms{};

	Parms.bIsFastReloadMulti = bIsFastReloadMulti;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.ReloadCheckTimer
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ReloadCheckTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ReloadCheckTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ReloadCount
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ReloadCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ReloadCount");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ReloadEvent
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ReloadEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ReloadEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ResetMeleeGate
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ResetMeleeGate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ResetMeleeGate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.SelectAmmoTypes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBPE_AmmoType                           Param_AmmoType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EBPE_AmmoType                           AmmoType_Default                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EBPE_AmmoType                           AmmoType_Piercing                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SelectAmmoTypes(EBPE_AmmoType Param_AmmoType, EBPE_AmmoType* AmmoType_Default, EBPE_AmmoType* AmmoType_Piercing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SelectAmmoTypes");

	Params::BP_Weapon_C_SelectAmmoTypes Parms{};

	Parms.Param_AmmoType = Param_AmmoType;

	UObject::ProcessEvent(Func, &Parms);

	if (AmmoType_Default != nullptr)
		*AmmoType_Default = Parms.AmmoType_Default;

	if (AmmoType_Piercing != nullptr)
		*AmmoType_Piercing = Parms.AmmoType_Piercing;
}


// Function BP_Weapon.BP_Weapon_C.SelectWeaponPlaceholder
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::SelectWeaponPlaceholder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SelectWeaponPlaceholder");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.SetAmmoType
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBPE_AmmoClass                          Param_AmmoClass                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EBPE_AmmoType                           Param_AmmoType                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SetAmmoType(EBPE_AmmoClass Param_AmmoClass, EBPE_AmmoType Param_AmmoType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SetAmmoType");

	Params::BP_Weapon_C_SetAmmoType Parms{};

	Parms.Param_AmmoClass = Param_AmmoClass;
	Parms.Param_AmmoType = Param_AmmoType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SetAttachmentsMultiplier
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_TypesOfModes                          Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  AttachmentMultiplier                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Attachment2Multiplier                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    WipeAllMultipliers                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SetAttachmentsMultiplier(E_TypesOfModes Type, double AttachmentMultiplier, double Attachment2Multiplier, bool WipeAllMultipliers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SetAttachmentsMultiplier");

	Params::BP_Weapon_C_SetAttachmentsMultiplier Parms{};

	Parms.Type = Type;
	Parms.AttachmentMultiplier = AttachmentMultiplier;
	Parms.Attachment2Multiplier = Attachment2Multiplier;
	Parms.WipeAllMultipliers = WipeAllMultipliers;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SetIsPlayEndRoundsSound
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsPlaySound                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SetIsPlayEndRoundsSound(const bool bIsPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SetIsPlayEndRoundsSound");

	Params::BP_Weapon_C_SetIsPlayEndRoundsSound Parms{};

	Parms.bIsPlaySound = bIsPlaySound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SetSkMesh
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::SetSkMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SetSkMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.SetSupressedSound
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Supressed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SetSupressedSound(bool Supressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SetSupressedSound");

	Params::BP_Weapon_C_SetSupressedSound Parms{};

	Parms.Supressed = Supressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SetWeaponIcon
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::SetWeaponIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SetWeaponIcon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ShootDirection
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BeginPoint                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EndPoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CamForwardVector                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::ShootDirection(struct FVector* BeginPoint, struct FVector* EndPoint, struct FVector* CamForwardVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ShootDirection");

	Params::BP_Weapon_C_ShootDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BeginPoint != nullptr)
		*BeginPoint = std::move(Parms.BeginPoint);

	if (EndPoint != nullptr)
		*EndPoint = std::move(Parms.EndPoint);

	if (CamForwardVector != nullptr)
		*CamForwardVector = std::move(Parms.CamForwardVector);
}


// Function BP_Weapon.BP_Weapon_C.Shotgun_Cycle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ForciblyEnd                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::Shotgun_Cycle(bool ForciblyEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "Shotgun_Cycle");

	Params::BP_Weapon_C_Shotgun_Cycle Parms{};

	Parms.ForciblyEnd = ForciblyEnd;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.ShotgunBulletIn
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ShotgunBulletIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ShotgunBulletIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.SimpleToCommon
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FS_SimplifiedHitInfo             Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// struct FHitResult                       S_SimplifiedHitInfo                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Weapon_C::SimpleToCommon(const struct FS_SimplifiedHitInfo& Hit, struct FHitResult* S_SimplifiedHitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SimpleToCommon");

	Params::BP_Weapon_C_SimpleToCommon Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (S_SimplifiedHitInfo != nullptr)
		*S_SimplifiedHitInfo = std::move(Parms.S_SimplifiedHitInfo);
}


// Function BP_Weapon.BP_Weapon_C.SimulateLocalMontage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Attacked                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SimulateLocalMontage(class UObject* Attacked, class FName BoneName, double Damage, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SimulateLocalMontage");

	Params::BP_Weapon_C_SimulateLocalMontage Parms{};

	Parms.Attacked = Attacked;
	Parms.BoneName = BoneName;
	Parms.Damage = Damage;
	Parms.HitLocation = std::move(HitLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SingleShot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::SingleShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SingleShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.Spawnd Decal
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInterface*               DecalMaterial                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class USceneComponent*                  AttachToComponent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Weapon_C::Spawnd_Decal(class UMaterialInterface* DecalMaterial, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "Spawnd Decal");

	Params::BP_Weapon_C_Spawnd_Decal Parms{};

	Parms.DecalMaterial = DecalMaterial;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SpawnDecal
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       BlockingHit                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    WasHit                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SpawnDecal(const struct FHitResult& BlockingHit, bool WasHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SpawnDecal");

	Params::BP_Weapon_C_SpawnDecal Parms{};

	Parms.BlockingHit = std::move(BlockingHit);
	Parms.WasHit = WasHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SpawnProjectile_Client
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Spawn_Transform_Location                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Spawn_Transform_Rotation                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Spawn_Transform_Scale                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESpawnActorCollisionHandlingMethod      CollisionHandlingOverride                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Param_Owner                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// struct FBPS_WeaponData                  Param_WeaponData                                       (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    ShowTrace                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UNiagaraSystem*                   NiagaraSystem                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::SpawnProjectile_Client(const struct FVector& Spawn_Transform_Location, const struct FRotator& Spawn_Transform_Rotation, const struct FVector& Spawn_Transform_Scale, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Param_Owner, const struct FBPS_WeaponData& Param_WeaponData, bool ShowTrace, class UNiagaraSystem* NiagaraSystem, class APawn* Param_Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SpawnProjectile_Client");

	Params::BP_Weapon_C_SpawnProjectile_Client Parms{};

	Parms.Spawn_Transform_Location = std::move(Spawn_Transform_Location);
	Parms.Spawn_Transform_Rotation = std::move(Spawn_Transform_Rotation);
	Parms.Spawn_Transform_Scale = std::move(Spawn_Transform_Scale);
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Param_Owner = Param_Owner;
	Parms.Param_WeaponData = std::move(Param_WeaponData);
	Parms.ShowTrace = ShowTrace;
	Parms.NiagaraSystem = NiagaraSystem;
	Parms.Param_Instigator = Param_Instigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.SpreadDecreasing
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::SpreadDecreasing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "SpreadDecreasing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.StopShakes
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::StopShakes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "StopShakes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.TriggerHipFireAnim
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_HipFireMode                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::TriggerHipFireAnim(bool Param_HipFireMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "TriggerHipFireAnim");

	Params::BP_Weapon_C_TriggerHipFireAnim Parms{};

	Parms.Param_HipFireMode = Param_HipFireMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WeaponShot
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  StartingPosition                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WeaponShot(double StartingPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WeaponShot");

	Params::BP_Weapon_C_WeaponShot Parms{};

	Parms.StartingPosition = StartingPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_Aiming
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Aim                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_Aiming(bool Aim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_Aiming");

	Params::BP_Weapon_C_WP_Aiming Parms{};

	Parms.Aim = Aim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_Anim_Weapon_Equiped
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Weapon_C*                     NewParam                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_Anim_Weapon_Equiped(class ABP_Weapon_C* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_Anim_Weapon_Equiped");

	Params::BP_Weapon_C_WP_Anim_Weapon_Equiped Parms{};

	Parms.NewParam = NewParam;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_EquipWeapon
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_WeaponName                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_EquipWeapon(class FName Param_WeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_EquipWeapon");

	Params::BP_Weapon_C_WP_EquipWeapon Parms{};

	Parms.Param_WeaponName = Param_WeaponName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_GetAimCamera
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 Camera                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_GetAimCamera(class UCameraComponent** Camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_GetAimCamera");

	Params::BP_Weapon_C_WP_GetAimCamera Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Camera != nullptr)
		*Camera = Parms.Camera;
}


// Function BP_Weapon.BP_Weapon_C.WP_GetLefHandEffectorTransform
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HasEffector                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_GetLefHandEffectorTransform(struct FTransform* Transform, bool* HasEffector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_GetLefHandEffectorTransform");

	Params::BP_Weapon_C_WP_GetLefHandEffectorTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	if (HasEffector != nullptr)
		*HasEffector = Parms.HasEffector;
}


// Function BP_Weapon.BP_Weapon_C.WP_GetRotationInput
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_GetRotationInput(struct FVector2D* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_GetRotationInput");

	Params::BP_Weapon_C_WP_GetRotationInput Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = std::move(Parms.NewParam);
}


// Function BP_Weapon.BP_Weapon_C.WP_GetShootDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ShootDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_GetShootDirection(struct FVector* ShootDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_GetShootDirection");

	Params::BP_Weapon_C_WP_GetShootDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ShootDirection != nullptr)
		*ShootDirection = std::move(Parms.ShootDirection);
}


// Function BP_Weapon.BP_Weapon_C.WP_GetSkeletalMesh
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkinnedMesh                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_GetSkeletalMesh(class USkeletalMeshComponent** SkinnedMesh, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_GetSkeletalMesh");

	Params::BP_Weapon_C_WP_GetSkeletalMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkinnedMesh != nullptr)
		*SkinnedMesh = Parms.SkinnedMesh;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_Weapon.BP_Weapon_C.WP_GetWeaponType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBPE_Weapon_Type                        Param_WeaponType                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_GetWeaponType(EBPE_Weapon_Type* Param_WeaponType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_GetWeaponType");

	Params::BP_Weapon_C_WP_GetWeaponType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_WeaponType != nullptr)
		*Param_WeaponType = Parms.Param_WeaponType;
}


// Function BP_Weapon.BP_Weapon_C.WP_HasWeaponOrBroken
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Value                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_HasWeaponOrBroken(bool* Param_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_HasWeaponOrBroken");

	Params::BP_Weapon_C_WP_HasWeaponOrBroken Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Value != nullptr)
		*Param_Value = Parms.Param_Value;
}


// Function BP_Weapon.BP_Weapon_C.WP_MeleeActivation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_MeleeActivation(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_MeleeActivation");

	Params::BP_Weapon_C_WP_MeleeActivation Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_PlayGunTail
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFMODEvent*                       TailSound                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_PlayGunTail(class UFMODEvent* TailSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_PlayGunTail");

	Params::BP_Weapon_C_WP_PlayGunTail Parms{};

	Parms.TailSound = TailSound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_SetRecoilPower
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Param_RecoilPower                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Weapon_C::WP_SetRecoilPower(double Param_RecoilPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_SetRecoilPower");

	Params::BP_Weapon_C_WP_SetRecoilPower Parms{};

	Parms.Param_RecoilPower = Param_RecoilPower;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Weapon.BP_Weapon_C.WP_UnequipWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::WP_UnequipWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "WP_UnequipWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Weapon.BP_Weapon_C.ZeroingBurstShots
// (BlueprintCallable, BlueprintEvent)

void ABP_Weapon_C::ZeroingBurstShots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Weapon_C", "ZeroingBurstShots");

	UObject::ProcessEvent(Func, nullptr);
}

}

