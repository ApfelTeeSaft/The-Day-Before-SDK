#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JSIContainer

#include "Basic.hpp"

#include "JSIContainer_classes.hpp"
#include "JSIContainer_parameters.hpp"


namespace SDK
{

// Function JSIContainer.JSIContainer_C.AddMultipleInventoryItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<int32>                           ItemIDs                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<int32>                           NotAdded                                               (Parm, OutParm)

void UJSIContainer_C::AddMultipleInventoryItems(TArray<int32>& ItemIDs, TArray<int32>* NotAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddMultipleInventoryItems");

	Params::JSIContainer_C_AddMultipleInventoryItems Parms{};

	Parms.ItemIDs = std::move(ItemIDs);

	UObject::ProcessEvent(Func, &Parms);

	ItemIDs = std::move(Parms.ItemIDs);

	if (NotAdded != nullptr)
		*NotAdded = std::move(Parms.NotAdded);
}


// Function JSIContainer.JSIContainer_C.AddNewInventoryItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryToStack_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       CustomInfo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       ItemInfo                                               (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   StackRemainder                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddNewInventoryItem(class FName ItemId, int32 Count, int32 ToSlot, bool Rotated_, bool TryRotated_, bool TryToStack_, const struct FFItemInfo& CustomInfo, bool* Added, int32* SlotIndex, struct FFItemInfo* ItemInfo, class UJSI_Slot_C** SlotItemRef, int32* StackRemainder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddNewInventoryItem");

	Params::JSIContainer_C_AddNewInventoryItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.ToSlot = ToSlot;
	Parms.Rotated_ = Rotated_;
	Parms.TryRotated_ = TryRotated_;
	Parms.TryToStack_ = TryToStack_;
	Parms.CustomInfo = std::move(CustomInfo);

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (ItemInfo != nullptr)
		*ItemInfo = std::move(Parms.ItemInfo);

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;

	if (StackRemainder != nullptr)
		*StackRemainder = Parms.StackRemainder;
}


// Function JSIContainer.JSIContainer_C.AddNewInventoryItem_CustomVector
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        OriginalSize                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       CustomInfo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       ItemInfo                                               (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddNewInventoryItem_CustomVector(class FName ItemId, int32 Count, int32 ToSlot, const struct FVector2D& SlotVector, const struct FVector2D& OriginalSize, const struct FFItemInfo& CustomInfo, bool* Added, int32* SlotIndex, struct FFItemInfo* ItemInfo, class UJSI_Slot_C** SlotItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddNewInventoryItem_CustomVector");

	Params::JSIContainer_C_AddNewInventoryItem_CustomVector Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.ToSlot = ToSlot;
	Parms.SlotVector = std::move(SlotVector);
	Parms.OriginalSize = std::move(OriginalSize);
	Parms.CustomInfo = std::move(CustomInfo);

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (ItemInfo != nullptr)
		*ItemInfo = std::move(Parms.ItemInfo);

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;
}


// Function JSIContainer.JSIContainer_C.AddNewItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftObjectPtr<class UObject>           Image                                                  (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESlotRarity                             Rarity                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    SetVector                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddedToSlot                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       Info                                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddNewItem(int32 ToSlot, TSoftObjectPtr<class UObject> Image, const struct FVector2D& SlotVector, ESlotRarity Rarity, const struct FFItemInfo& ItemInfo, bool SetVector, bool* Added, int32* AddedToSlot, struct FFItemInfo* Info, class UJSI_Slot_C** SlotItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddNewItem");

	Params::JSIContainer_C_AddNewItem Parms{};

	Parms.ToSlot = ToSlot;
	Parms.Image = Image;
	Parms.SlotVector = std::move(SlotVector);
	Parms.Rarity = Rarity;
	Parms.ItemInfo = std::move(ItemInfo);
	Parms.SetVector = SetVector;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (AddedToSlot != nullptr)
		*AddedToSlot = Parms.AddedToSlot;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;
}


// Function JSIContainer.JSIContainer_C.AddSortHighlightedTypes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<EJSItemType>                     Types                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSIContainer_C::AddSortHighlightedTypes(const TArray<EJSItemType>& Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddSortHighlightedTypes");

	Params::JSIContainer_C_AddSortHighlightedTypes Parms{};

	Parms.Types = std::move(Types);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CalculateSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector2D UJSIContainer_C::CalculateSize(const struct FVector2D& SlotVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CalculateSize");

	Params::JSIContainer_C_CalculateSize Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.CalculateSizeCustom
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        CSlotSize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector2D UJSIContainer_C::CalculateSizeCustom(const struct FVector2D& SlotVector, const struct FVector2D& CSlotSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CalculateSizeCustom");

	Params::JSIContainer_C_CalculateSizeCustom Parms{};

	Parms.SlotVector = std::move(SlotVector);
	Parms.CSlotSize = std::move(CSlotSize);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.CalculateWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CalculateWeight(double* Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CalculateWeight");

	Params::JSIContainer_C_CalculateWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weight != nullptr)
		*Weight = Parms.Weight;
}


// Function JSIContainer.JSIContainer_C.Call Container On Container
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ToSlotRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_DragRotated_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Call_Container_On_Container(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool Param_DragRotated_, bool TryRotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Call Container On Container");

	Params::JSIContainer_C_Call_Container_On_Container Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotRef = SlotRef;
	Parms.ToSlotRef = ToSlotRef;
	Parms.ToSlot = ToSlot;
	Parms.Param_DragRotated_ = Param_DragRotated_;
	Parms.TryRotated_ = TryRotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CancelHighlights
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Drop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CancelHighlights(bool Drop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CancelHighlights");

	Params::JSIContainer_C_CancelHighlights Parms{};

	Parms.Drop = Drop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CancelHlight
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::CancelHlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CancelHlight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.CanItAllFitIn
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UJSI_Slot_C*>              Param_ArrayOfItems                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    CanFit_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanItAllFitIn(TArray<class UJSI_Slot_C*>& Param_ArrayOfItems, bool* CanFit_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanItAllFitIn");

	Params::JSIContainer_C_CanItAllFitIn Parms{};

	Parms.Param_ArrayOfItems = std::move(Param_ArrayOfItems);

	UObject::ProcessEvent(Func, &Parms);

	Param_ArrayOfItems = std::move(Parms.Param_ArrayOfItems);

	if (CanFit_ != nullptr)
		*CanFit_ = Parms.CanFit_;
}


// Function JSIContainer.JSIContainer_C.CanResize?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToX                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToY                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              HostingSlotsArray                                      (Parm, OutParm, ContainsInstancedReference)
// TArray<class UJSI_Slot_C*>              FreedHostingSlotsArray                                 (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::CanResize_(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Result, TArray<class UJSI_Slot_C*>* HostingSlotsArray, TArray<class UJSI_Slot_C*>* FreedHostingSlotsArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanResize?");

	Params::JSIContainer_C_CanResize_ Parms{};

	Parms.SlotRef = SlotRef;
	Parms.AddToX = AddToX;
	Parms.AddToY = AddToY;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (HostingSlotsArray != nullptr)
		*HostingSlotsArray = std::move(Parms.HostingSlotsArray);

	if (FreedHostingSlotsArray != nullptr)
		*FreedHostingSlotsArray = std::move(Parms.FreedHostingSlotsArray);
}


// Function JSIContainer.JSIContainer_C.CanStack?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Canstack                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanStack_(class UJSIContainer_C* Container, const struct FFItemInfo& ItemInfo, bool* Canstack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanStack?");

	Params::JSIContainer_C_CanStack_ Parms{};

	Parms.Container = Container;
	Parms.ItemInfo = std::move(ItemInfo);

	UObject::ProcessEvent(Func, &Parms);

	if (Canstack != nullptr)
		*Canstack = Parms.Canstack;
}


// Function JSIContainer.JSIContainer_C.CanStackSingleSlot?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFItemInfo                       Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanStackSingleSlot_(const struct FFItemInfo& Info, bool* Sucess, class UJSI_Slot_C** ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanStackSingleSlot?");

	Params::JSIContainer_C_CanStackSingleSlot_ Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;
}


// Function JSIContainer.JSIContainer_C.ChangeItemCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemCount(class UJSI_Slot_C* ItemRef, int32 NewCount, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemCount");

	Params::JSIContainer_C_ChangeItemCount Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSIContainer.JSIContainer_C.ChangeItemImage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UPaperSprite*                     NewTexture                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemImage(class UJSI_Slot_C* ItemRef, class UPaperSprite* NewTexture, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemImage");

	Params::JSIContainer_C_ChangeItemImage Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewTexture = NewTexture;

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSIContainer.JSIContainer_C.ChangeItemRarity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// ESlotRarity                             NewRarity                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemRarity(class UJSI_Slot_C* ItemRef, ESlotRarity NewRarity, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemRarity");

	Params::JSIContainer_C_ChangeItemRarity Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewRarity = NewRarity;

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSIContainer.JSIContainer_C.ChangeItemsInteract
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interact_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemsInteract(bool Interact_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemsInteract");

	Params::JSIContainer_C_ChangeItemsInteract Parms{};

	Parms.Interact_ = Interact_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CheckAvailableItemsByName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckAvailableItemsByName(class FName Param_Name, int32 Count, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckAvailableItemsByName");

	Params::JSIContainer_C_CheckAvailableItemsByName Parms{};

	Parms.Param_Name = Param_Name;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function JSIContainer.JSIContainer_C.CheckCanRemoveBackpack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Pocket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    NotAllowed1                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckCanRemoveBackpack(class UJSIContainer_C* Pocket, bool* NotAllowed1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckCanRemoveBackpack");

	Params::JSIContainer_C_CheckCanRemoveBackpack Parms{};

	Parms.Pocket = Pocket;

	UObject::ProcessEvent(Func, &Parms);

	if (NotAllowed1 != nullptr)
		*NotAllowed1 = Parms.NotAllowed1;
}


// Function JSIContainer.JSIContainer_C.CheckEquippedSlots
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UMPInGameInventory_C*             Inventory                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::CheckEquippedSlots(class UJSIContainer_C* FromContainer, class UMPInGameInventory_C* Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckEquippedSlots");

	Params::JSIContainer_C_CheckEquippedSlots Parms{};

	Parms.FromContainer = FromContainer;
	Parms.Inventory = Inventory;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.CheckIsEmptySlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotDimension                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotEmpty                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckIsEmptySlot(int32 Param_Index, const struct FVector2D& SlotDimension, bool* NotEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckIsEmptySlot");

	Params::JSIContainer_C_CheckIsEmptySlot Parms{};

	Parms.Param_Index = Param_Index;
	Parms.SlotDimension = std::move(SlotDimension);

	UObject::ProcessEvent(Func, &Parms);

	if (NotEmpty != nullptr)
		*NotEmpty = Parms.NotEmpty;
}


// Function JSIContainer.JSIContainer_C.CheckIsEmptySlots
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckIsEmptySlots(TArray<class UJSI_Slot_C*>& Array, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckIsEmptySlots");

	Params::JSIContainer_C_CheckIsEmptySlots Parms{};

	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function JSIContainer.JSIContainer_C.CheckItemBeforeEquip
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FFItemInfo                       ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FFItemInfo                       Result                                                 (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UJSIContainer_C::CheckItemBeforeEquip(const struct FFItemInfo& ItemInfo, struct FFItemInfo* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckItemBeforeEquip");

	Params::JSIContainer_C_CheckItemBeforeEquip Parms{};

	Parms.ItemInfo = std::move(ItemInfo);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function JSIContainer.JSIContainer_C.CheckMoneyMoveToCase
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Allow                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckMoneyMoveToCase(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, bool* Allow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckMoneyMoveToCase");

	Params::JSIContainer_C_CheckMoneyMoveToCase Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotRef = SlotRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Allow != nullptr)
		*Allow = Parms.Allow;
}


// Function JSIContainer.JSIContainer_C.CheckTutorial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Param_Slot                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  OnContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Locked                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCase                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckTutorial(class UJSI_Slot_C* Param_Slot, class UJSIContainer_C* OnContainer, class UJSIContainer_C* FromContainer, bool* Locked, bool* IsCase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckTutorial");

	Params::JSIContainer_C_CheckTutorial Parms{};

	Parms.Param_Slot = Param_Slot;
	Parms.OnContainer = OnContainer;
	Parms.FromContainer = FromContainer;

	UObject::ProcessEvent(Func, &Parms);

	if (Locked != nullptr)
		*Locked = Parms.Locked;

	if (IsCase != nullptr)
		*IsCase = Parms.IsCase;
}


// Function JSIContainer.JSIContainer_C.ClearContainer
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ClearContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ClearContainerOccupation
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ClearContainerOccupation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearContainerOccupation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ClearData
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ClearData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ClearSelection
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ClearSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.CombineItemRequest
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotDropped                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerEventDispatcher_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CombineItemRequest(class UJSIContainer_C* FromContainer, class UJSI_Slot_C* SlotRec, class UJSI_Slot_C* SlotDropped, bool TriggerEventDispatcher_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CombineItemRequest");

	Params::JSIContainer_C_CombineItemRequest Parms{};

	Parms.FromContainer = FromContainer;
	Parms.SlotRec = SlotRec;
	Parms.SlotDropped = SlotDropped;
	Parms.TriggerEventDispatcher_ = TriggerEventDispatcher_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Construct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UJSIContainer_C::Construct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Construct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.DeleteItemInfo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::DeleteItemInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DeleteItemInfo");

	Params::JSIContainer_C_DeleteItemInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.DeleteSelectItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::DeleteSelectItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DeleteSelectItem");

	Params::JSIContainer_C_DeleteSelectItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.Destruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UJSIContainer_C::Destruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Destruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.DragEnd__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::DragEnd__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DragEnd__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.DragStart__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::DragStart__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DragStart__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.Drop_ContainerOnContainerUnhandled__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      DroppedSlotRef                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotReceiverRef                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlotIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RightMouseButton                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Drop_ContainerOnContainerUnhandled__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool Rotated_, bool RightMouseButton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Drop_ContainerOnContainerUnhandled__DelegateSignature");

	Params::JSIContainer_C_Drop_ContainerOnContainerUnhandled__DelegateSignature Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.DroppedSlotRef = DroppedSlotRef;
	Parms.SlotReceiverRef = SlotReceiverRef;
	Parms.ToSlotIndex = ToSlotIndex;
	Parms.Rotated_ = Rotated_;
	Parms.RightMouseButton = RightMouseButton;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Drop_ItemOverItem__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemReceiver                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemDropped                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ItemReceiverContainer                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ItemDroppedContainer                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Drop_ItemOverItem__DelegateSignature(class UJSI_Slot_C* ItemReceiver, class UJSI_Slot_C* ItemDropped, class UJSIContainer_C* ItemReceiverContainer, class UJSIContainer_C* ItemDroppedContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Drop_ItemOverItem__DelegateSignature");

	Params::JSIContainer_C_Drop_ItemOverItem__DelegateSignature Parms{};

	Parms.ItemReceiver = ItemReceiver;
	Parms.ItemDropped = ItemDropped;
	Parms.ItemReceiverContainer = ItemReceiverContainer;
	Parms.ItemDroppedContainer = ItemDroppedContainer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.DropInfo_ContainerToContainer__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  From                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  To                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      FromSlotRef                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ToSlotRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ToEmptySlot_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MovedAll_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::DropInfo_ContainerToContainer__DelegateSignature(class UJSIContainer_C* From, class UJSIContainer_C* To, class UJSI_Slot_C* FromSlotRef, class UJSI_Slot_C* ToSlotRef, bool ToEmptySlot_, bool MovedAll_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DropInfo_ContainerToContainer__DelegateSignature");

	Params::JSIContainer_C_DropInfo_ContainerToContainer__DelegateSignature Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.FromSlotRef = FromSlotRef;
	Parms.ToSlotRef = ToSlotRef;
	Parms.ToEmptySlot_ = ToEmptySlot_;
	Parms.MovedAll_ = MovedAll_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.DropInfo_OnItemEquippedChange__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Equipped_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToPockets_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::DropInfo_OnItemEquippedChange__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, bool Equipped_, bool ToPockets_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DropInfo_OnItemEquippedChange__DelegateSignature");

	Params::JSIContainer_C_DropInfo_OnItemEquippedChange__DelegateSignature Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotRef = SlotRef;
	Parms.Equipped_ = Equipped_;
	Parms.ToPockets_ = ToPockets_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.DropInfo_SplitPerformed__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SourceSlotRef                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      NewSplitSlotRef                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ContainerSource                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ContainerReceiver                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   SplitAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AmountRemaining                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::DropInfo_SplitPerformed__DelegateSignature(class UJSI_Slot_C* SourceSlotRef, class UJSI_Slot_C* NewSplitSlotRef, class UJSIContainer_C* ContainerSource, class UJSIContainer_C* ContainerReceiver, int32 SplitAmount, int32 AmountRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DropInfo_SplitPerformed__DelegateSignature");

	Params::JSIContainer_C_DropInfo_SplitPerformed__DelegateSignature Parms{};

	Parms.SourceSlotRef = SourceSlotRef;
	Parms.NewSplitSlotRef = NewSplitSlotRef;
	Parms.ContainerSource = ContainerSource;
	Parms.ContainerReceiver = ContainerReceiver;
	Parms.SplitAmount = SplitAmount;
	Parms.AmountRemaining = AmountRemaining;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Equip Item
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFItemInfo                       CustomInfo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class UJSIContainer_C*                  SlotContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerEquippedEvent_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Equipped                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Equip_Item(class FName ItemId, const struct FVector2D& SlotVector, const struct FFItemInfo& CustomInfo, class UJSIContainer_C* SlotContainer, bool TriggerEquippedEvent_, bool* Equipped, class UJSI_Slot_C** SlotItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Equip Item");

	Params::JSIContainer_C_Equip_Item Parms{};

	Parms.ItemId = ItemId;
	Parms.SlotVector = std::move(SlotVector);
	Parms.CustomInfo = std::move(CustomInfo);
	Parms.SlotContainer = SlotContainer;
	Parms.TriggerEquippedEvent_ = TriggerEquippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Equipped != nullptr)
		*Equipped = Parms.Equipped;

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;
}


// Function JSIContainer.JSIContainer_C.EventSelectItem__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::EventSelectItem__DelegateSignature(class UJSI_Slot_C* Item, class UJSIContainer_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "EventSelectItem__DelegateSignature");

	Params::JSIContainer_C_EventSelectItem__DelegateSignature Parms{};

	Parms.Item = Item;
	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.ExecuteUbergraph_JSIContainer
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ExecuteUbergraph_JSIContainer(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ExecuteUbergraph_JSIContainer");

	Params::JSIContainer_C_ExecuteUbergraph_JSIContainer Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.FlipSlotDim
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Flipped                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::FlipSlotDim(const struct FVector2D& SlotVector, struct FVector2D* Flipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "FlipSlotDim");

	Params::JSIContainer_C_FlipSlotDim Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (Flipped != nullptr)
		*Flipped = std::move(Parms.Flipped);
}


// Function JSIContainer.JSIContainer_C.GenerateEmptySlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   MinRows                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MinColumns                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GenerateEmptySlots(int32 MinRows, int32 MinColumns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GenerateEmptySlots");

	Params::JSIContainer_C_GenerateEmptySlots Parms{};

	Parms.MinRows = MinRows;
	Parms.MinColumns = MinColumns;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.GenerateEmptySlots (OnDrag)
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      JSISlot                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyReset                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GenerateEmptySlots__OnDrag_(class UJSI_Slot_C* JSISlot, bool OnlyReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GenerateEmptySlots (OnDrag)");

	Params::JSIContainer_C_GenerateEmptySlots__OnDrag_ Parms{};

	Parms.JSISlot = JSISlot;
	Parms.OnlyReset = OnlyReset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Get Max YDimension
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotsCount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Get_Max_YDimension(class UJSIContainer_C* Container, int32* SlotsCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Get Max YDimension");

	Params::JSIContainer_C_Get_Max_YDimension Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotsCount != nullptr)
		*SlotsCount = Parms.SlotsCount;
}


// Function JSIContainer.JSIContainer_C.GetColumnRowBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Column                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetColumnRowBySlotIndex(int32 SlotIndex, int32* Column, int32* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetColumnRowBySlotIndex");

	Params::JSIContainer_C_GetColumnRowBySlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Column != nullptr)
		*Column = Parms.Column;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function JSIContainer.JSIContainer_C.GetContainerCapacity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetContainerCapacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerCapacity");

	Params::JSIContainer_C_GetContainerCapacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetContainerHierarchy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Containers                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetContainerHierarchy(TArray<class UJSIContainer_C*>* Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerHierarchy");

	Params::JSIContainer_C_GetContainerHierarchy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);
}


// Function JSIContainer.JSIContainer_C.GetContainerName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Param_ContainerName                                    (Parm, OutParm)

void UJSIContainer_C::GetContainerName(class FText* Param_ContainerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerName");

	Params::JSIContainer_C_GetContainerName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_ContainerName != nullptr)
		*Param_ContainerName = std::move(Parms.Param_ContainerName);
}


// Function JSIContainer.JSIContainer_C.GetCountFreeSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetCountFreeSlots(int32* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetCountFreeSlots");

	Params::JSIContainer_C_GetCountFreeSlots Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function JSIContainer.JSIContainer_C.GetDropSlotWithOffset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SizeX                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SizeY                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PivotIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex1                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetDropSlotWithOffset(int32 SizeX, int32 SizeY, int32 SlotIndex, int32 PivotIndex, int32* SlotIndex1, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetDropSlotWithOffset");

	Params::JSIContainer_C_GetDropSlotWithOffset Parms{};

	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.SlotIndex = SlotIndex;
	Parms.PivotIndex = PivotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotIndex1 != nullptr)
		*SlotIndex1 = Parms.SlotIndex1;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JSIContainer.JSIContainer_C.GetEmptySlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OccupyAfterCheck                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetEmptySlot(const struct FVector2D& SlotVector, bool OccupyAfterCheck, int32* SlotIndex, bool* Found_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetEmptySlot");

	Params::JSIContainer_C_GetEmptySlot Parms{};

	Parms.SlotVector = std::move(SlotVector);
	Parms.OccupyAfterCheck = OccupyAfterCheck;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;
}


// Function JSIContainer.JSIContainer_C.GetEquippedItemRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetEquippedItemRef(bool* Found_, class UJSI_Slot_C** ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetEquippedItemRef");

	Params::JSIContainer_C_GetEquippedItemRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;
}


// Function JSIContainer.JSIContainer_C.GetInventoryItemsByID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetInventoryItemsByID(int32 ItemId, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetInventoryItemsByID");

	Params::JSIContainer_C_GetInventoryItemsByID Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetInventoryItemsByName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetInventoryItemsByName(class FName ItemName, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetInventoryItemsByName");

	Params::JSIContainer_C_GetInventoryItemsByName Parms{};

	Parms.ItemName = ItemName;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetInventoryItemsByType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EJSItemType                             Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetInventoryItemsByType(EJSItemType Type, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetInventoryItemsByType");

	Params::JSIContainer_C_GetInventoryItemsByType Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetItemBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetItemBySlotIndex(int32 SlotIndex, bool* Found, class UJSI_Slot_C** Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemBySlotIndex");

	Params::JSIContainer_C_GetItemBySlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Item != nullptr)
		*Item = Parms.Item;
}


// Function JSIContainer.JSIContainer_C.GetItemByUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UniqueId                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetItemByUniqueID(int32 UniqueId, bool* Found, class UJSI_Slot_C** Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemByUniqueID");

	Params::JSIContainer_C_GetItemByUniqueID Parms{};

	Parms.UniqueId = UniqueId;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Item != nullptr)
		*Item = Parms.Item;
}


// Function JSIContainer.JSIContainer_C.GetItemsByRarity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlotRarity                             Rarity                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetItemsByRarity(ESlotRarity Rarity, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemsByRarity");

	Params::JSIContainer_C_GetItemsByRarity Parms{};

	Parms.Rarity = Rarity;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetItemsCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetItemsCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemsCount");

	Params::JSIContainer_C_GetItemsCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetLength
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetLength");

	Params::JSIContainer_C_GetLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetLowestSlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// int32                                   MinIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetLowestSlotIndex(TArray<class UJSI_Slot_C*>& Array, int32* MinIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetLowestSlotIndex");

	Params::JSIContainer_C_GetLowestSlotIndex Parms{};

	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (MinIndex != nullptr)
		*MinIndex = Parms.MinIndex;
}


// Function JSIContainer.JSIContainer_C.GetMaxCountSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetMaxCountSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetMaxCountSlots");

	Params::JSIContainer_C_GetMaxCountSlots Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetNumberOfFreeSlots
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Num                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetNumberOfFreeSlots(int32* Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetNumberOfFreeSlots");

	Params::JSIContainer_C_GetNumberOfFreeSlots Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Num != nullptr)
		*Num = Parms.Num;
}


// Function JSIContainer.JSIContainer_C.GetPaddingBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FMargin                          Param_Padding                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   Conumn                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetPaddingBySlotIndex(int32 SlotIndex, const struct FVector2D& SlotVector, struct FMargin* Param_Padding, int32* Conumn, int32* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetPaddingBySlotIndex");

	Params::JSIContainer_C_GetPaddingBySlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Padding != nullptr)
		*Param_Padding = std::move(Parms.Param_Padding);

	if (Conumn != nullptr)
		*Conumn = Parms.Conumn;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function JSIContainer.JSIContainer_C.GetRootContainerRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ExcludeEquipTo                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ContainerRef                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetRootContainerRef(bool ExcludeEquipTo, class UJSIContainer_C** ContainerRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetRootContainerRef");

	Params::JSIContainer_C_GetRootContainerRef Parms{};

	Parms.ExcludeEquipTo = ExcludeEquipTo;

	UObject::ProcessEvent(Func, &Parms);

	if (ContainerRef != nullptr)
		*ContainerRef = Parms.ContainerRef;
}


// Function JSIContainer.JSIContainer_C.GetSelecetItemName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Param_Name                                             (Parm, OutParm)

void UJSIContainer_C::GetSelecetItemName(class FText* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSelecetItemName");

	Params::JSIContainer_C_GetSelecetItemName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);
}


// Function JSIContainer.JSIContainer_C.GetSelectItemInfo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFItemInfo                       ItemInfo                                               (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UJSIContainer_C::GetSelectItemInfo(struct FFItemInfo* ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSelectItemInfo");

	Params::JSIContainer_C_GetSelectItemInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemInfo != nullptr)
		*ItemInfo = std::move(Parms.ItemInfo);
}


// Function JSIContainer.JSIContainer_C.GetSlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetSlotIndex(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSlotIndex");

	Params::JSIContainer_C_GetSlotIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JSIContainer.JSIContainer_C.GetSlotIndexByColumnRow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Column                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetSlotIndexByColumnRow(int32 Column, int32 Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSlotIndexByColumnRow");

	Params::JSIContainer_C_GetSlotIndexByColumnRow Parms{};

	Parms.Column = Column;
	Parms.Row = Row;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetSlotMotherUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnContainerID_IfInvalid_                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   UDID                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetSlotMotherUID(bool ReturnContainerID_IfInvalid_, int32* UDID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSlotMotherUID");

	Params::JSIContainer_C_GetSlotMotherUID Parms{};

	Parms.ReturnContainerID_IfInvalid_ = ReturnContainerID_IfInvalid_;

	UObject::ProcessEvent(Func, &Parms);

	if (UDID != nullptr)
		*UDID = Parms.UDID;
}


// Function JSIContainer.JSIContainer_C.GetWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetWeight(double* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetWeight");

	Params::JSIContainer_C_GetWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function JSIContainer.JSIContainer_C.HandleContainerOnContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ToSlotRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DraggedRotated_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Handled_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::HandleContainerOnContainer(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool DraggedRotated_, bool TryRotated_, bool* Handled_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HandleContainerOnContainer");

	Params::JSIContainer_C_HandleContainerOnContainer Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotRef = SlotRef;
	Parms.ToSlotRef = ToSlotRef;
	Parms.ToSlot = ToSlot;
	Parms.DraggedRotated_ = DraggedRotated_;
	Parms.TryRotated_ = TryRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Handled_ != nullptr)
		*Handled_ = Parms.Handled_;
}


// Function JSIContainer.JSIContainer_C.HighlightItemsByType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<EJSItemType>                     Types                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSIContainer_C::HighlightItemsByType(TArray<EJSItemType>& Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HighlightItemsByType");

	Params::JSIContainer_C_HighlightItemsByType Parms{};

	Parms.Types = std::move(Types);

	UObject::ProcessEvent(Func, &Parms);

	Types = std::move(Parms.Types);
}


// Function JSIContainer.JSIContainer_C.HighlightSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        MouseLoc                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRecRef                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PivotIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::HighlightSlots(int32 SlotIndex, const struct FVector2D& SlotVector, const struct FVector2D& MouseLoc, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* SlotRecRef, bool Rotated_, bool Supported_, int32 PivotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HighlightSlots");

	Params::JSIContainer_C_HighlightSlots Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SlotVector = std::move(SlotVector);
	Parms.MouseLoc = std::move(MouseLoc);
	Parms.SlotRef = SlotRef;
	Parms.SlotRecRef = SlotRecRef;
	Parms.Rotated_ = Rotated_;
	Parms.Supported_ = Supported_;
	Parms.PivotIndex = PivotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Hightlight_DragMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      DragSlotRef                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PivotIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Hightlight_DragMove(int32 SlotIndex, class UJSI_Slot_C* DragSlotRef, class UJSI_Slot_C* SlotRec, bool Rotated_, int32 PivotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Hightlight_DragMove");

	Params::JSIContainer_C_Hightlight_DragMove Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.DragSlotRef = DragSlotRef;
	Parms.SlotRec = SlotRec;
	Parms.Rotated_ = Rotated_;
	Parms.PivotIndex = PivotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Initialize
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Design_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Initialize(bool Design_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Initialize");

	Params::JSIContainer_C_Initialize Parms{};

	Parms.Design_ = Design_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.IsEquipped?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsEquipped_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsEquipped?");

	Params::JSIContainer_C_IsEquipped_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.IsSupportedID?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::IsSupportedID_(int32 ID, bool* Supported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsSupportedID?");

	Params::JSIContainer_C_IsSupportedID_ Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	if (Supported != nullptr)
		*Supported = Parms.Supported;
}


// Function JSIContainer.JSIContainer_C.IsSupportedType?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<EJSItemType>                     Param_SupportedItemTypes                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EJSItemType                             Type                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::IsSupportedType_(TArray<EJSItemType>& Param_SupportedItemTypes, const EJSItemType& Type, int32 ItemId, bool* Supported_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsSupportedType?");

	Params::JSIContainer_C_IsSupportedType_ Parms{};

	Parms.Param_SupportedItemTypes = std::move(Param_SupportedItemTypes);
	Parms.Type = Type;
	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	Param_SupportedItemTypes = std::move(Parms.Param_SupportedItemTypes);

	if (Supported_ != nullptr)
		*Supported_ = Parms.Supported_;
}


// Function JSIContainer.JSIContainer_C.Items Filter Surv
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::Items_Filter_Surv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Items Filter Surv");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.Items FilterDupl
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::Items_FilterDupl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Items FilterDupl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ItemsCombined__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotReceiver                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotDropped                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    SlotDroppedRemoved_                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ItemsCombined__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotReceiver, class UJSI_Slot_C* SlotDropped, bool SlotDroppedRemoved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ItemsCombined__DelegateSignature");

	Params::JSIContainer_C_ItemsCombined__DelegateSignature Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotReceiver = SlotReceiver;
	Parms.SlotDropped = SlotDropped;
	Parms.SlotDroppedRemoved_ = SlotDroppedRemoved_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.ItemsDispatcher__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ItemsDispatcher__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ItemsDispatcher__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ItemsFilterEvent
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ItemsFilterEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ItemsFilterEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ItemsFilterEventDelayer
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ItemsFilterEventDelayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ItemsFilterEventDelayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.MakeCell
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::MakeCell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MakeCell");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.MoveHighlighter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemSlot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              Highlighted                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Candrop                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::MoveHighlighter(class UJSI_Slot_C* ItemSlot, TArray<class UJSI_Slot_C*>& Highlighted, bool Candrop, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MoveHighlighter");

	Params::JSIContainer_C_MoveHighlighter Parms{};

	Parms.ItemSlot = ItemSlot;
	Parms.Highlighted = std::move(Highlighted);
	Parms.Candrop = Candrop;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);

	Highlighted = std::move(Parms.Highlighted);
}


// Function JSIContainer.JSIContainer_C.MoveItemToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::MoveItemToContainer(class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemRef, int32 Count, int32 ToSlot, bool Rotated_, bool* Moved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MoveItemToContainer");

	Params::JSIContainer_C_MoveItemToContainer Parms{};

	Parms.ToContainer = ToContainer;
	Parms.ItemRef = ItemRef;
	Parms.Count = Count;
	Parms.ToSlot = ToSlot;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved_ != nullptr)
		*Moved_ = Parms.Moved_;
}


// Function JSIContainer.JSIContainer_C.MoveItemToIndexByItemRef
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotate_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::MoveItemToIndexByItemRef(class UJSI_Slot_C* ItemRef, int32 ToIndex, bool Rotate_, bool* Moved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MoveItemToIndexByItemRef");

	Params::JSIContainer_C_MoveItemToIndexByItemRef Parms{};

	Parms.ItemRef = ItemRef;
	Parms.ToIndex = ToIndex;
	Parms.Rotate_ = Rotate_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved_ != nullptr)
		*Moved_ = Parms.Moved_;
}


// Function JSIContainer.JSIContainer_C.MoveItemToIndexBySlotIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemSlotIndex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotate_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::MoveItemToIndexBySlotIndex(int32 ItemSlotIndex, int32 ToIndex, bool Rotate_, bool* Moved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MoveItemToIndexBySlotIndex");

	Params::JSIContainer_C_MoveItemToIndexBySlotIndex Parms{};

	Parms.ItemSlotIndex = ItemSlotIndex;
	Parms.ToIndex = ToIndex;
	Parms.Rotate_ = Rotate_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved_ != nullptr)
		*Moved_ = Parms.Moved_;
}


// Function JSIContainer.JSIContainer_C.NavigationChange
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EUINavigation                           Direaction                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::NavigationChange(EUINavigation Direaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "NavigationChange");

	Params::JSIContainer_C_NavigationChange Parms{};

	Parms.Direaction = Direaction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnContainerUpdate__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::OnContainerUpdate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnContainerUpdate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.OnDragEnter
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Param_Operation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Param_Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDragEnter");

	Params::JSIContainer_C_OnDragEnter Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Param_Operation = Param_Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnDragLeave
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Param_Operation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Param_Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDragLeave");

	Params::JSIContainer_C_OnDragLeave Parms{};

	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Param_Operation = Param_Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnDrop
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Param_Operation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Param_Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDrop");

	Params::JSIContainer_C_OnDrop Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Param_Operation = Param_Operation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.OnItemSlotOrRotationChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   NewIndex                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnItemSlotOrRotationChanged__DelegateSignature(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, int32 NewIndex, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnItemSlotOrRotationChanged__DelegateSignature");

	Params::JSIContainer_C_OnItemSlotOrRotationChanged__DelegateSignature Parms{};

	Parms.Container = Container;
	Parms.SlotRef = SlotRef;
	Parms.NewIndex = NewIndex;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnItemSplitRequest__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemSource                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlotIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SplitAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnItemSplitRequest__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemSource, int32 ToSlotIndex, int32 TotalAmount, int32 SplitAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnItemSplitRequest__DelegateSignature");

	Params::JSIContainer_C_OnItemSplitRequest__DelegateSignature Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.ItemSource = ItemSource;
	Parms.ToSlotIndex = ToSlotIndex;
	Parms.TotalAmount = TotalAmount;
	Parms.SplitAmount = SplitAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnItemStackRequest__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DroppedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ReceiverItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnItemStackRequest__DelegateSignature(class UJSI_Slot_C* DroppedItem, class UJSI_Slot_C* ReceiverItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnItemStackRequest__DelegateSignature");

	Params::JSIContainer_C_OnItemStackRequest__DelegateSignature Parms{};

	Parms.DroppedItem = DroppedItem;
	Parms.ReceiverItem = ReceiverItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnKeyDown
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FKeyEvent                        InKeyEvent                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSIContainer_C::OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnKeyDown");

	Params::JSIContainer_C_OnKeyDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.OnMouseLeave
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSIContainer_C::OnMouseLeave(const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnMouseLeave");

	Params::JSIContainer_C_OnMouseLeave Parms{};

	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnPlayerDeath
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::OnPlayerDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnPlayerDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.OnSlotDoubleClick__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FKey                             Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UJSIContainer_C::OnSlotDoubleClick__DelegateSignature(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnSlotDoubleClick__DelegateSignature");

	Params::JSIContainer_C_OnSlotDoubleClick__DelegateSignature Parms{};

	Parms.Container = Container;
	Parms.SlotRef = SlotRef;
	Parms.Button = std::move(Button);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnSlotMouseButtonDown__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FKey                             Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UJSIContainer_C::OnSlotMouseButtonDown__DelegateSignature(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnSlotMouseButtonDown__DelegateSignature");

	Params::JSIContainer_C_OnSlotMouseButtonDown__DelegateSignature Parms{};

	Parms.Container = Container;
	Parms.SlotRef = SlotRef;
	Parms.Button = std::move(Button);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnStackCountChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnStackCountChanged__DelegateSignature(class UJSI_Slot_C* ItemRef, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnStackCountChanged__DelegateSignature");

	Params::JSIContainer_C_OnStackCountChanged__DelegateSignature Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.PerfromDrop
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::PerfromDrop(int32 SlotIndex, const struct FVector2D& SlotVector, class UJSI_Slot_C* SlotRef, bool Rotated_, bool* Moved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "PerfromDrop");

	Params::JSIContainer_C_PerfromDrop Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SlotVector = std::move(SlotVector);
	Parms.SlotRef = SlotRef;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved != nullptr)
		*Moved = Parms.Moved;
}


// Function JSIContainer.JSIContainer_C.PreConstruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsDesignTime                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::PreConstruct(bool IsDesignTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "PreConstruct");

	Params::JSIContainer_C_PreConstruct Parms{};

	Parms.IsDesignTime = IsDesignTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Re-Init
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Columns                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Rows                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ReMinusInit(int32 Columns, int32 Rows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Re-Init");

	Params::JSIContainer_C_ReMinusInit Parms{};

	Parms.Columns = Columns;
	Parms.Rows = Rows;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Re-SortHighlightItems
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ReMinusSortHighlightItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Re-SortHighlightItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.RecalculateHighlighretSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  SingleSlotSizeX                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  SingleSlotSizeY                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Dimention                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DistanceBetweenSlots                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RecalculateHighlighretSize(double SingleSlotSizeX, double SingleSlotSizeY, const struct FVector2D& Dimention, double DistanceBetweenSlots, struct FVector2D* Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RecalculateHighlighretSize");

	Params::JSIContainer_C_RecalculateHighlighretSize Parms{};

	Parms.SingleSlotSizeX = SingleSlotSizeX;
	Parms.SingleSlotSizeY = SingleSlotSizeY;
	Parms.Dimention = std::move(Dimention);
	Parms.DistanceBetweenSlots = DistanceBetweenSlots;

	UObject::ProcessEvent(Func, &Parms);

	if (Size != nullptr)
		*Size = std::move(Parms.Size);
}


// Function JSIContainer.JSIContainer_C.RecalculateHighlighterDim
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              Slots                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FVector2D                        Dimention                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RecalculateHighlighterDim(TArray<class UJSI_Slot_C*>& Slots, struct FVector2D* Dimention)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RecalculateHighlighterDim");

	Params::JSIContainer_C_RecalculateHighlighterDim Parms{};

	Parms.Slots = std::move(Slots);

	UObject::ProcessEvent(Func, &Parms);

	Slots = std::move(Parms.Slots);

	if (Dimention != nullptr)
		*Dimention = std::move(Parms.Dimention);
}


// Function JSIContainer.JSIContainer_C.RecalculateHighlitherPosition
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              Slots                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Position                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RecalculateHighlitherPosition(TArray<class UJSI_Slot_C*>& Slots, bool Rotated, struct FVector2D* Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RecalculateHighlitherPosition");

	Params::JSIContainer_C_RecalculateHighlitherPosition Parms{};

	Parms.Slots = std::move(Slots);
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);

	Slots = std::move(Parms.Slots);

	if (Position != nullptr)
		*Position = std::move(Parms.Position);
}


// Function JSIContainer.JSIContainer_C.RemoveInventoryItemByRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Removed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RemoveInventoryItemByRef(class UJSI_Slot_C* SlotRef, bool* Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RemoveInventoryItemByRef");

	Params::JSIContainer_C_RemoveInventoryItemByRef Parms{};

	Parms.SlotRef = SlotRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Removed != nullptr)
		*Removed = Parms.Removed;
}


// Function JSIContainer.JSIContainer_C.RemoveItemByUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RemoveItemByUniqueID(int32 ID, bool* Sucess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RemoveItemByUniqueID");

	Params::JSIContainer_C_RemoveItemByUniqueID Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;
}


// Function JSIContainer.JSIContainer_C.RemoveSortHighlightedTypes
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<EJSItemType>                     Types                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSIContainer_C::RemoveSortHighlightedTypes(TArray<EJSItemType>& Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RemoveSortHighlightedTypes");

	Params::JSIContainer_C_RemoveSortHighlightedTypes Parms{};

	Parms.Types = std::move(Types);

	UObject::ProcessEvent(Func, &Parms);

	Types = std::move(Parms.Types);
}


// Function JSIContainer.JSIContainer_C.ResizeItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToX                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToY                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Resized_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ResizeItem(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Resized_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ResizeItem");

	Params::JSIContainer_C_ResizeItem Parms{};

	Parms.SlotRef = SlotRef;
	Parms.AddToX = AddToX;
	Parms.AddToY = AddToY;

	UObject::ProcessEvent(Func, &Parms);

	if (Resized_ != nullptr)
		*Resized_ = Parms.Resized_;
}


// Function JSIContainer.JSIContainer_C.SelectRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    DroppedRotated_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SelectRotation(class UJSI_Slot_C* ItemRef, bool DroppedRotated_, bool* Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SelectRotation");

	Params::JSIContainer_C_SelectRotation Parms{};

	Parms.ItemRef = ItemRef;
	Parms.DroppedRotated_ = DroppedRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Rotated != nullptr)
		*Rotated = Parms.Rotated;
}


// Function JSIContainer.JSIContainer_C.SelectSlot
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FKey                             Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UJSIContainer_C::SelectSlot(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SelectSlot");

	Params::JSIContainer_C_SelectSlot Parms{};

	Parms.Container = Container;
	Parms.SlotRef = SlotRef;
	Parms.Button = std::move(Button);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetBGColorOfDragWidget
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDragDropOperation*               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Candrop                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Leave                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetBGColorOfDragWidget(class UDragDropOperation* Target, bool Candrop, bool Leave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetBGColorOfDragWidget");

	Params::JSIContainer_C_SetBGColorOfDragWidget Parms{};

	Parms.Target = Target;
	Parms.Candrop = Candrop;
	Parms.Leave = Leave;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetHightlightBrush
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        Dim                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Candrop                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPaperSprite*                     BG_Sprite1                                             (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void UJSIContainer_C::SetHightlightBrush(const struct FVector2D& Dim, bool Candrop, class UPaperSprite** BG_Sprite1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetHightlightBrush");

	Params::JSIContainer_C_SetHightlightBrush Parms{};

	Parms.Dim = std::move(Dim);
	Parms.Candrop = Candrop;

	UObject::ProcessEvent(Func, &Parms);

	if (BG_Sprite1 != nullptr)
		*BG_Sprite1 = Parms.BG_Sprite1;
}


// Function JSIContainer.JSIContainer_C.SetNavigationWidget_Left
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                          NavigationWidget                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetNavigationWidget_Left(class UWidget* NavigationWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetNavigationWidget_Left");

	Params::JSIContainer_C_SetNavigationWidget_Left Parms{};

	Parms.NavigationWidget = NavigationWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SomeFunctionBool
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::SomeFunctionBool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SomeFunctionBool");

	Params::JSIContainer_C_SomeFunctionBool Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.StopDrag
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::StopDrag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "StopDrag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.StopDragAndDrop
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::StopDragAndDrop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "StopDragAndDrop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.TakeAllItems
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::TakeAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "TakeAllItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.Tick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   InDeltaTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Tick(const struct FGeometry& MyGeometry, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Tick");

	Params::JSIContainer_C_Tick Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.UnequipItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    TriggerUnequippedEvent_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Unequipped                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::UnequipItem(bool TriggerUnequippedEvent_, bool* Unequipped, class UJSI_Slot_C** SlotRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "UnequipItem");

	Params::JSIContainer_C_UnequipItem Parms{};

	Parms.TriggerUnequippedEvent_ = TriggerUnequippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Unequipped != nullptr)
		*Unequipped = Parms.Unequipped;

	if (SlotRef != nullptr)
		*SlotRef = Parms.SlotRef;
}


// Function JSIContainer.JSIContainer_C.Unselect__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::Unselect__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Unselect__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.UpdateCountByUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::UpdateCountByUniqueID(int32 ID, int32 NewCount, bool* Sucess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "UpdateCountByUniqueID");

	Params::JSIContainer_C_UpdateCountByUniqueID Parms{};

	Parms.ID = ID;
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;
}


// Function JSIContainer.JSIContainer_C.UpdateTitle
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::UpdateTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "UpdateTitle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.GetDropOffset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   SizeX                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SizeY                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PivotIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   X_Offset                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Y_Offset                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetDropOffset(int32 SizeX, int32 SizeY, int32 PivotIndex, int32* X_Offset, int32* Y_Offset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetDropOffset");

	Params::JSIContainer_C_GetDropOffset Parms{};

	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.PivotIndex = PivotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (X_Offset != nullptr)
		*X_Offset = Parms.X_Offset;

	if (Y_Offset != nullptr)
		*Y_Offset = Parms.Y_Offset;
}


// Function JSIContainer.JSIContainer_C.GetIndexBySlotLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   Row                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Col                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetIndexBySlotLocation(int32 Row, int32 Col, int32* SlotIndex, bool* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetIndexBySlotLocation");

	Params::JSIContainer_C_GetIndexBySlotLocation Parms{};

	Parms.Row = Row;
	Parms.Col = Col;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JSIContainer.JSIContainer_C.GetSlotLocationByIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   SlotIndex_Loc                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ColumnIndex_                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RowIndex_                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetSlotLocationByIndex(int32 SlotIndex_Loc, int32* ColumnIndex_, int32* RowIndex_) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSlotLocationByIndex");

	Params::JSIContainer_C_GetSlotLocationByIndex Parms{};

	Parms.SlotIndex_Loc = SlotIndex_Loc;

	UObject::ProcessEvent(Func, &Parms);

	if (ColumnIndex_ != nullptr)
		*ColumnIndex_ = Parms.ColumnIndex_;

	if (RowIndex_ != nullptr)
		*RowIndex_ = Parms.RowIndex_;
}

}

