#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MPMainContainerBox

#include "Basic.hpp"

#include "E_InteractType_structs.hpp"
#include "ServerSlotInfoArray_structs.hpp"
#include "Engine_structs.hpp"
#include "Survival_classes.hpp"
#include "DefaultItemInfo_structs.hpp"
#include "E_ActorType_structs.hpp"
#include "ContainerPickupsInfo_structs.hpp"
#include "E_LockpickDifficulty_structs.hpp"
#include "LootGeneratorType_structs.hpp"
#include "ELootTypes_structs.hpp"
#include "LootPointType_structs.hpp"
#include "SlotRarity_structs.hpp"
#include "LG2_LootRareType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass MPMainContainerBox.MPMainContainerBox_C
// 0x0228 (0x04B8 - 0x0290)
class AMPMainContainerBox_C : public AMainContainerBox
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0290(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	bool                                          RandomGenerate;                                    // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ContainerName;                                     // 0x02A8(0x0018)(Edit, BlueprintVisible, Net, ExposeOnSpawn)
	class UMPContainerWidget_C*                   ContainerWidget;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TArray<struct FDefaultItemInfo>               ContainerItems;                                    // 0x02C8(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference, ExposeOnSpawn)
	FMulticastInlineDelegateProperty_             OnContainerAction;                                 // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         CurrentContainerID;                                // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FContainerPickupsInfo>          MPContainers;                                      // 0x02F0(0x0010)(Edit, BlueprintVisible, Net, ContainsInstancedReference)
	TArray<struct FContainerPickupsInfo>          MPContainerItems;                                  // 0x0300(0x0010)(Edit, BlueprintVisible, Net, ContainsInstancedReference)
	class UDataTable*                             DataTable;                                         // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         CurrentUID;                                        // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MainNumOfColumns;                                  // 0x031C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         MainNumOfRows;                                     // 0x0320(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          DataRequested;                                     // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FServerSlotInfoArray>           MPContainerSlotDataS;                              // 0x0328(0x0010)(Edit, BlueprintVisible)
	TMap<int32, class UJSIContainer_C*>           ContainerWidgets;                                  // 0x0338(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          DataBuilt;                                         // 0x0388(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ELootGeneratorType                            LootGeneratorType;                                 // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  UsingPlayer;                                       // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             LootGeneratorAsset;                                // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         MaxItemsCount;                                     // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPDA_ChanceModifier_C*                  LootChanceModAsset;                                // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          IsShop;                                            // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WidgetInited;                                      // 0x03B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3B2[0x6];                                      // 0x03B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             MovedToChar;                                       // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UMPContainerWidget_v2_C*                ContainerWidget_v2;                                // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	int32                                         ChanceTier4;                                       // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             WeaponDataTable;                                   // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         ChanceTier5;                                       // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CanStackItem;                                      // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomIndexGenerate;                               // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         RandomCountMoney;                                  // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ChanceMoney;                                       // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MinMoney;                                          // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MaxMoney;                                          // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          GenerateItemsInventory;                            // 0x03FC(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          NeedGenerate;                                      // 0x03FD(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3FE[0x2];                                      // 0x03FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContainerItemsCount;                               // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          LootOpened;                                        // 0x0404(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsLocked;                                         // 0x0405(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          bCurrentLockState;                                 // 0x0406(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_LockpickDifficulty                          LockpickDiffuculty;                                // 0x0407(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class ABP_LockpickingGame_C*                  LockpickingGameActor;                              // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          RespawnContainerItems;                             // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDefaultItemInfo>               ContainerItemsForRespawn;                          // 0x0418(0x0010)(Edit, BlueprintVisible, Net, ContainsInstancedReference)
	TArray<struct FContainerPickupsInfo>          MPContainerItemsForRespawn;                        // 0x0428(0x0010)(Edit, BlueprintVisible, Net, ContainsInstancedReference)
	bool                                          CanCloseDoor;                                      // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItemsPerContainer;                              // 0x043C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         LootedCount;                                       // 0x0440(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSIContainer_C*                        JSIContainer;                                      // 0x0448(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UJSI_Slot_C*                            Slot_Item_Ref;                                     // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UJSI_Slot_C*                            PointedItemSlot;                                   // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TMap<class UQuest*, double>                   QuestList;                                         // 0x0460(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          bFreePickup;                                       // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ActivateQuest();
	void AddContainersToDictionary(TArray<class UJSIContainer_C*>& Containers);
	void AddContainerToContainer(const struct FContainerPickupsInfo& Container, TArray<struct FContainerPickupsInfo>& ContainerData, TArray<struct FContainerPickupsInfo>& Param_ContainerItems, int32 ToContainerUID, int32 ToSlot, bool Rotated_, bool NotSync);
	void AddItemToContainer(int32 ToContainerUID, int32 ToSlotIndex, const struct FContainerPickupsInfo& ItemPInfo, bool Rotated_, bool CallMCEvent_, bool* Added);
	void AddItemToContainer_NoData(int32 ContainerUID, int32 NOfColumns, int32 NOfRows, const struct FVector2D& SlotVector, bool* Added, int32* AddedTo, TArray<int32>* HostingSlots);
	void AddItemToDropBox__Multicast_(class AActor* Actor, const struct FDefaultItemInfo& Item);
	void AddItemToFreeSlot__OnlyServer_(int32 ContainerUID, const struct FDefaultItemInfo& Item, bool AutoUpdate, bool* Result, struct FContainerPickupsInfo* Container);
	void BlindAddNewItemToContainer(const struct FVector2D& SlotVector, int32 ItemUID, int32 ToContainerUID, bool Shop, bool* Added, int32* ToSlotIndex, int32* UniqueId);
	void BuildContainerDataToWidget(TArray<struct FContainerPickupsInfo>& ItemData_Containers, TArray<struct FContainerPickupsInfo>& ItemData_Items, class UJSIContainer_C* MainContainer, TArray<class UJSIContainer_C*>* CreatedContainerList);
	void BuildContainerSlotData(int32 NumOfColumns, int32 NumOfRows, int32 ContainerUID, bool Shop);
	void BuildData__OnlyServer_(const struct FS_LootChanceModifier& LootChanceMod, bool ReMinusBuild);
	void CallLootAnim(double LootingHeight, bool LootPointOpened);
	void CampBuildInstant();
	void CampPlaceBegin();
	void CampPlaceEnd();
	bool CheckTierAndLootTypes(const struct FFItemInfo& FItemInfo, class ATDB_GameMode_C* GameMode, TArray<class FName>* ArrayTypes);
	void CompleteQuest(int32 QuestIndex, int32 ObjectiveIndex);
	void ContainerBoxClosed();
	void ContainerOpened();
	void Craft(class APawn* Player);
	void DestroyInteractable();
	void DoesItemExist(int32 Uid, bool IsContainer_, bool* Exists, struct FContainerPickupsInfo* PickupItem, int32* ArrayIndex);
	void EventOnContainerAction(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool Rotated_, bool RightMouseButton);
	void ExecuteUbergraph_MPMainContainerBox(int32 EntryPoint);
	void GenerateContainerItems(const struct FS_LootChanceModifier& LootChanceMod, TArray<struct FDefaultItemInfo>* Items);
	void GenerateRandomItemsOnType(ELootTypes Type, ESlotRarity LootTier, int32 Chance, class FName* ID, bool* Canstack, int32* MaxCountStack, class ATDB_GameMode_C** AsTDB_Game_Mode);
	void Get_Rand_Unique_Item(const class UQuestData_C* QuestData, class ASurvivalPlayer_C* Surv, class FString* ItemName);
	void GetActorType(E_ActorType* ActorType);
	void GetColumnRowBySlotIndex(int32 SlotIndex, int32 NumOfColumns, int32 NumOfRows, int32* Column, int32* Row);
	void GetCompiledContainerStructure(const struct FFItemInfo& Item, const struct FDefaultItemInfo& DefItem, int32 ContainerMotherID, int32 SlotIndex, bool AutoUpdateChild, bool* Result, struct FContainerPickupsInfo* Container);
	void GetFreePickup(bool* Param_bFreePickup);
	void GetHostingSlots(int32 InIndex, int32 NOfColumns, int32 NOfRows, const struct FVector2D& ItemVector, TArray<int32>* Indexes);
	void GetMainContainer(class UMPContainerWidget_C** Param_ContainerWidget);
	void GetPointedItemSlot(class UJSI_Slot_C** Param_PointedItemSlot);
	void GetRandCurrentQuestsData(class ASurvPC_C* Controller, class UQuestData_C** AsQuest_Data, double* Chance);
	void GetReplicatedData__OnlyServer_(class APawn* Player, const struct FS_LootChanceModifier& LootChanceMod, struct FMpContentRep* Data);
	void GetRotation(bool ItemRotated_, bool DroppedRotation, bool* Rotated);
	void GetSlotDataArrIndexByUID(int32 Uid, bool Shop, int32* Param_Index);
	int32 GetSlotIndexByRowColumn(int32 Column, int32 Row, int32 NumOfColumns);
	void GetUniqueServerID(int32* NewUID);
	void GetVector(bool Rotated, const struct FVector2D& Vector, struct FVector2D* NewVector);
	void GI_TileLoaded(class FName TileName);
	void GI_TileUnloaded(class FName TileName);
	void HandleContainersEvents(class UJSIContainer_C* Container, bool SetID_);
	void HeatUpBonfire(class APawn* Player);
	void InitContainerWidget__Main_();
	void InMPCMoveItem(int32 ItemUID, int32 ToContainerUID, int32 ToIndex, bool Rotated_, bool IsContainer);
	void Interact(bool NewParam);
	void InteractController();
	void IsInWater(bool* InWater);
	void IsLocked_(bool* Result);
	void IsLootPoint(bool* Result, class ALootPoint_C** Loot);
	void IsPlayer(bool* Param_IsPlayer);
	void MC_AddNewContainer(int32 ToContainerUID, const struct FContainerPickupsInfo& PickupItem, int32 ToSlot, bool Rotated_, const TArray<struct FContainerPickupsInfo>& ContainerData, const TArray<struct FContainerPickupsInfo>& Param_ContainerItems, bool BlockAddContainer);
	void MC_AddNewItemToContainer(int32 ToContainerUID, const struct FContainerPickupsInfo& PickupItem, int32 ToSlot);
	void MC_InMPCMoveItem(int32 ItemUID, int32 FromContainerUID, int32 ToContainerUID, int32 ToIndex, bool Rotated_);
	void MC_MPContainerMoveItem(int32 ContainerID, int32 ItemSlotIndex, int32 ToSlotIndex, bool Rotated_);
	void MC_RemoveItem(int32 ContainerUID, int32 ItemUID);
	void MC_UpdateItemCount(int32 ContainerUID, int32 ItemUID, int32 Count);
	void MovedToChar__DelegateSignature(class FName NewParam);
	void MoveItemToSlotInContainer(int32 NOfColumns, int32 NumOfRows, int32 ToSlotIndex, int32 ItemUID, const struct FVector2D& ItemVector, int32 ItemSlotIndex, int32 ToContainerUID, bool IsContainer, bool Rotated_, bool* Moved, int32* ToSlot, int32* ItemId, int32* ContainerUID);
	void MPCFindItem(int32 ContainerUID, int32 ItemUID, bool IsContainer_, bool Shop, bool* Found, struct FContainerPickupsInfo* ItemInfo, int32* Param_Index);
	void MPContToFull(const struct FMpContentRep& Content, TArray<struct FContainerPickupsInfo>* Containers, TArray<struct FContainerPickupsInfo>* Param_ContainerItems);
	void MPCRemoveItem(int32 Uid, bool IsContainer_, bool Shop, bool* Removed);
	void MPCUpdateItemInfo(const struct FContainerPickupsInfo& Item);
	void OnBeginInteract(class APawn* Player);
	void OnContainerAction__DelegateSignature(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool DroppedRotated_);
	void OnFocused(class APawn* Player, class AActor* HighlightActor, class UActorComponent* HighlightActorComponent, E_InteractType* InteractType, double* LateTime);
	void OnInteract(class APawn* Player);
	void OnInteract2(class APawn* Player);
	void OnInteract3(class APawn* Player);
	void OnInteractVehicle(class APawn* Player, int32 SitIndex, bool SkipAnimation);
	void OnLocalInteract(class APawn* Player);
	void OnLostFocus(class APawn* Player);
	void OnRep_MPContainerItems();
	void OnRep_NeedGenerate();
	void OnSeen(class APawn* Player);
	void OnSquadCheckComplete();
	void OnStopInteract(class APawn* Player);
	void OpenDoorRPC(class ABP_Door_C* Door, bool IsOpen);
	void OpenLootRPC(class ALootPoint_C* LootPoint);
	void PlayerAddItem(const struct FFItemInfo& ItemInfo, class UWBP_AttachmentCell_C* ActiveCell, bool* Added);
	void PlayerCanisterAction(bool Attach, class ABP_Canister_C* Canister);
	void PlayerGetItemCount(class UObject* Target, const class FString& ItemName, int32* Count);
	void PlayerGetMesh(class USkeletalMeshComponent** Mesh);
	void PlayerHasWeapon(class UObject* Target, bool* Value);
	void PlayerItemCountByName(const class FString& ItemName, int32* Count);
	void ReceiveBeginPlay();
	void RemoveContainerCustom(int32 ItemUID, bool IsContainer_);
	void RequestMoveItem(int32 ToSlotIndex, int32 ItemUID, int32 ToContainerUID, bool Rotated_, bool IsContainer, bool CallMCEvent_, bool Shop, bool* Moved);
	void ResetGenerateItemsSpawnEvent();
	void Run_Lockpicking();
	void RunOpenLogicAfterLockpicking();
	void Set3DWidgetVisibility(bool Visible);
	void SetContainerPermissions(class UJSIContainer_C* Container);
	void SetEnableSmoothSync(bool NewEnable, bool* Success);
	void SetFreePickup(bool Param_bFreePickup);
	void SetPlayerCollisionInCar(bool NewEnable);
	void SetTutorial3DWidgetVisibility(bool Visible);
	void ShowSimpleUIText(const class FString& String);
	void StopLockpicking_binding_(bool Success);
	void TransferMPCDataToChar(const struct FContainerPickupsInfo& ContainerInfo, int32 ContainerIndex, bool Shop, int32 ItemsLeft, bool* Success, TArray<struct FContainerPickupsInfo>* ContainerDataResult, TArray<struct FContainerPickupsInfo>* ContainerItemsResult);
	void UnhandleAllEvents(class UJSIContainer_C* Container);
	void UpdateContainerData__OnlyServer_(TArray<struct FContainerPickupsInfo>& InContainers, bool ReMinusInit, bool* Result);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"MPMainContainerBox_C">();
	}
	static class AMPMainContainerBox_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMPMainContainerBox_C>();
	}
};
static_assert(alignof(AMPMainContainerBox_C) == 0x000008, "Wrong alignment on AMPMainContainerBox_C");
static_assert(sizeof(AMPMainContainerBox_C) == 0x0004B8, "Wrong size on AMPMainContainerBox_C");
static_assert(offsetof(AMPMainContainerBox_C, UberGraphFrame) == 0x000290, "Member 'AMPMainContainerBox_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, DefaultSceneRoot) == 0x000298, "Member 'AMPMainContainerBox_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, RandomGenerate) == 0x0002A0, "Member 'AMPMainContainerBox_C::RandomGenerate' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerName) == 0x0002A8, "Member 'AMPMainContainerBox_C::ContainerName' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerWidget) == 0x0002C0, "Member 'AMPMainContainerBox_C::ContainerWidget' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerItems) == 0x0002C8, "Member 'AMPMainContainerBox_C::ContainerItems' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, OnContainerAction) == 0x0002D8, "Member 'AMPMainContainerBox_C::OnContainerAction' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, CurrentContainerID) == 0x0002E8, "Member 'AMPMainContainerBox_C::CurrentContainerID' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MPContainers) == 0x0002F0, "Member 'AMPMainContainerBox_C::MPContainers' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MPContainerItems) == 0x000300, "Member 'AMPMainContainerBox_C::MPContainerItems' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, DataTable) == 0x000310, "Member 'AMPMainContainerBox_C::DataTable' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, CurrentUID) == 0x000318, "Member 'AMPMainContainerBox_C::CurrentUID' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MainNumOfColumns) == 0x00031C, "Member 'AMPMainContainerBox_C::MainNumOfColumns' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MainNumOfRows) == 0x000320, "Member 'AMPMainContainerBox_C::MainNumOfRows' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, DataRequested) == 0x000324, "Member 'AMPMainContainerBox_C::DataRequested' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MPContainerSlotDataS) == 0x000328, "Member 'AMPMainContainerBox_C::MPContainerSlotDataS' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerWidgets) == 0x000338, "Member 'AMPMainContainerBox_C::ContainerWidgets' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, DataBuilt) == 0x000388, "Member 'AMPMainContainerBox_C::DataBuilt' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LootGeneratorType) == 0x000389, "Member 'AMPMainContainerBox_C::LootGeneratorType' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, UsingPlayer) == 0x000390, "Member 'AMPMainContainerBox_C::UsingPlayer' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LootGeneratorAsset) == 0x000398, "Member 'AMPMainContainerBox_C::LootGeneratorAsset' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MaxItemsCount) == 0x0003A0, "Member 'AMPMainContainerBox_C::MaxItemsCount' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LootChanceModAsset) == 0x0003A8, "Member 'AMPMainContainerBox_C::LootChanceModAsset' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, IsShop) == 0x0003B0, "Member 'AMPMainContainerBox_C::IsShop' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, WidgetInited) == 0x0003B1, "Member 'AMPMainContainerBox_C::WidgetInited' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MovedToChar) == 0x0003B8, "Member 'AMPMainContainerBox_C::MovedToChar' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerWidget_v2) == 0x0003C8, "Member 'AMPMainContainerBox_C::ContainerWidget_v2' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ChanceTier4) == 0x0003D0, "Member 'AMPMainContainerBox_C::ChanceTier4' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, WeaponDataTable) == 0x0003D8, "Member 'AMPMainContainerBox_C::WeaponDataTable' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ChanceTier5) == 0x0003E0, "Member 'AMPMainContainerBox_C::ChanceTier5' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, CanStackItem) == 0x0003E4, "Member 'AMPMainContainerBox_C::CanStackItem' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, RandomIndexGenerate) == 0x0003E8, "Member 'AMPMainContainerBox_C::RandomIndexGenerate' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, RandomCountMoney) == 0x0003EC, "Member 'AMPMainContainerBox_C::RandomCountMoney' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ChanceMoney) == 0x0003F0, "Member 'AMPMainContainerBox_C::ChanceMoney' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MinMoney) == 0x0003F4, "Member 'AMPMainContainerBox_C::MinMoney' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MaxMoney) == 0x0003F8, "Member 'AMPMainContainerBox_C::MaxMoney' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, GenerateItemsInventory) == 0x0003FC, "Member 'AMPMainContainerBox_C::GenerateItemsInventory' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, NeedGenerate) == 0x0003FD, "Member 'AMPMainContainerBox_C::NeedGenerate' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerItemsCount) == 0x000400, "Member 'AMPMainContainerBox_C::ContainerItemsCount' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LootOpened) == 0x000404, "Member 'AMPMainContainerBox_C::LootOpened' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, bIsLocked) == 0x000405, "Member 'AMPMainContainerBox_C::bIsLocked' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, bCurrentLockState) == 0x000406, "Member 'AMPMainContainerBox_C::bCurrentLockState' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LockpickDiffuculty) == 0x000407, "Member 'AMPMainContainerBox_C::LockpickDiffuculty' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LockpickingGameActor) == 0x000408, "Member 'AMPMainContainerBox_C::LockpickingGameActor' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, RespawnContainerItems) == 0x000410, "Member 'AMPMainContainerBox_C::RespawnContainerItems' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, ContainerItemsForRespawn) == 0x000418, "Member 'AMPMainContainerBox_C::ContainerItemsForRespawn' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MPContainerItemsForRespawn) == 0x000428, "Member 'AMPMainContainerBox_C::MPContainerItemsForRespawn' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, CanCloseDoor) == 0x000438, "Member 'AMPMainContainerBox_C::CanCloseDoor' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, MaxItemsPerContainer) == 0x00043C, "Member 'AMPMainContainerBox_C::MaxItemsPerContainer' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, LootedCount) == 0x000440, "Member 'AMPMainContainerBox_C::LootedCount' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, JSIContainer) == 0x000448, "Member 'AMPMainContainerBox_C::JSIContainer' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, Slot_Item_Ref) == 0x000450, "Member 'AMPMainContainerBox_C::Slot_Item_Ref' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, PointedItemSlot) == 0x000458, "Member 'AMPMainContainerBox_C::PointedItemSlot' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, QuestList) == 0x000460, "Member 'AMPMainContainerBox_C::QuestList' has a wrong offset!");
static_assert(offsetof(AMPMainContainerBox_C, bFreePickup) == 0x0004B0, "Member 'AMPMainContainerBox_C::bFreePickup' has a wrong offset!");

}

