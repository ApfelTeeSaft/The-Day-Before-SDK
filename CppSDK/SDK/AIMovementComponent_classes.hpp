#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AIMovementComponent

#include "Basic.hpp"

#include "F_RotationCurvesMap_structs.hpp"
#include "Engine_structs.hpp"
#include "Survival_structs.hpp"
#include "Survival_classes.hpp"
#include "E_AIMovementType_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "E_PathMovementState_structs.hpp"
#include "F_MovementSettings_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass AIMovementComponent.AIMovementComponent_C
// 0x04C8 (0x0578 - 0x00B0)
class UAIMovementComponent_C final : public UAIMoveComp
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UCharacterMovementComponent*            CharMoveComp;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStopping;                                        // 0x00C0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ResultVelocity;                                    // 0x00C8(0x0018)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                VelocityDirection;                                 // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                DesiredVelocityDirection;                          // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        VelocityValue;                                     // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MaxVelocityValue;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MinVelocityValue;                                  // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DirectionInterpolationSpeed;                       // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UNavigationPath*                        Path;                                              // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<struct FVector_NetQuantize>            PathPoints;                                        // 0x0138(0x0010)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify)
	class AActor*                                 TargetActor;                                       // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 PathfindingContext;                                // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
	bool                                          TargetIsActor;                                     // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NextPathPointLocation;                             // 0x0168(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CurrentPathPointLocation;                          // 0x0180(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TargetPathGenerationLocation;                      // 0x0198(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                PathPointLocation;                                 // 0x01B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TargetLocation;                                    // 0x01C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CurrentPathPointIndex;                             // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        EndMovementSpeed;                                  // 0x01E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateAcceleration;                                 // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateDeceleration;                                 // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateMinSpeed;                                     // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          VelocityFromAnimation;                             // 0x0208(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DrawDebugLines;                                    // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OwnerLocation;                                     // 0x0210(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   VelocityCurveName;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ACharacter*                             Character;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UAnimInstance*                          CharacterAnimInstance;                             // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        AnimationAngle;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_AIMovementType                              MovementType;                                      // 0x0248(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	bool                                          RotationFromAnimation;                             // 0x0249(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_24A[0x2];                                      // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RotationCurveName;                                 // 0x024C(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StartRotationYawZ;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        TurnTime;                                          // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RotationYawZ;                                      // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AnimationRotationInterpolationSpeed;               // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_PathMovementState                           PathMovementState;                                 // 0x0270(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StateMaxSpeed;                                     // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateChangePointDist;                              // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DecreaseStateDist;                                 // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        IncreaseStateDist;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateDistanceToFilterPathPoints;                   // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateHighestAngle;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateLowestAngle;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StartChangingVelocityValue;                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnReachTarget;                                     // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          DrawDebugPathPoints;                               // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AParentAIDetourController_C*            CharacterController;                               // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        PathRegenerationDistance;                          // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateMinDirInterpSpeed;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateMaxDirInterpSpeed;                            // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateSpeedInterpSpeed;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateIsCloseToTargetDistance;                      // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateCloseDirInterpSpeed;                          // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StateAfterDecreasingAdjustment;                    // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          LastPointIsTargetActor;                            // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<E_AIMovementType, struct FF_MovementSettings> MovementSettings;                                  // 0x0318(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	double                                        StateTwistCheckDistance;                           // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TargetActorLocation;                               // 0x0370(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        EndPointMultiplier;                                // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          NeedPreciseCalculation;                            // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DistanceToTarget;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        TargetSpeedPrevious;                               // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ZombieInFront;                                     // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AZombie_C*                              Zombie;                                            // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           ZombieCheckTimer;                                  // 0x03B8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        DistanceToZombie;                                  // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x03C8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	TMap<Survival::EMovementType, struct FF_MovementSettings> MovementSettingsCPP;                               // 0x03D8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<Survival::EMovementType, struct FF_RotationCurvesMap> RotationCurves;                                    // 0x0428(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UCurveFloat*                            CurrentRotationCurve;                              // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        EndTime;                                           // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        DistanceToCurrentPathPoint;                        // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bSkipCalculations;                                 // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PreviousDistance;                                  // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAlwaysRecalculateMovement;                        // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SkipCalculationsDistance;                          // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsBlockedOnFront;                                 // 0x04B0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AZombie_C*                              ZombieBlockedBy;                                   // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           RotationExtractionSubtickTimer;                    // 0x04C0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         RotationSubtickInterval;                           // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               NewRotation;                                       // 0x04D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FTimerHandle                           RotationSubtickTimer;                              // 0x04E8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          bUseRotationSubtick;                               // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4F1[0x7];                                      // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MinDistanceBeforeLastPoint;                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           UnblockZombieTimer;                                // 0x0500(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        MinDistanceToStartMoving;                          // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        ReplicatedRotationZ;                               // 0x0510(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MinAngleToStopMovement;                            // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MaxClientAngleDifference;                          // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           UnblockZombieFromWaterTargetTimer;                 // 0x0528(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        VelocityLengthFromServer;                          // 0x0530(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCarInFront;                                       // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_539[0x7];                                      // 0x0539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AAVS_VehicleMaster_C*                   CarInFront;                                        // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CarHitLocation;                                    // 0x0548(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CarHitReflectionVector;                            // 0x0560(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ActivateComponent(bool TickEnabled);
	void AddCarAvoidingPoint(TArray<struct FVector>& InPoints, TArray<struct FVector>* OutPoints);
	void AddRandomPointNearTarget(TArray<struct FVector>& InPoints, TArray<struct FVector>* OutPoints);
	void AnalyzePath();
	void BlockZombie();
	void BlockZombieByWaterTarget();
	void Calculate_Desired_Direction(struct FVector* DesiredDirection);
	void CalculateCurrentPathPointLocation();
	void CalculateDirectionInterpolationSpeed(double* InterpolationSpeed);
	void CalculateDistanceToCurrentPoint();
	void CalculateDistanceToTarget();
	void CalculateNextPathPointLocation();
	void CalculateOwnerDirection(struct FVector* OwnerDirection);
	void CalculateOwnerLocation();
	void CalculateResultVelocity(struct FVector* Velocity);
	void CalculateTargetLocation();
	void CalculateTargetLocationDifference();
	void CalculateVelocity(double DeltaSeconds);
	void CalculateVelocityDirection(double DeltaSeconds, struct FVector* Direction);
	void CalculateVelocityValue(double DeltaSeconds, double* Param_VelocityValue);
	void CheckAnimationRotationStop(bool* Stop);
	void CheckHittedActor(class UObject* ActorHitted, const struct FVector& Hit_location);
	void CheckStartAngleIsTooBig();
	void CheckZombieInFront();
	void CPPMovementTypeRepNotify();
	void DeactivateComponent();
	void DebugShowPath();
	void DebugShowPathTrack();
	void DecreasingMovement();
	void DecreasingMovementSetup();
	void DefaultMovement();
	void DefaultMovementSetup();
	void DelayedUnsetAnimationMovement();
	void DetermineRotationCurve(Survival::EMovementType Param_MovementType, double Param_AnimationAngle);
	void DrawAIDebugLine(const struct FVector& Direction, const struct FLinearColor& LineColor, double DrawDistance, double DrawThickness);
	void DrawPathPoints();
	void ExecuteUbergraph_AIMovementComponent(int32 EntryPoint);
	void ExtractRotationFromAnimation(class FName Param_RotationCurveName, double Param_AnimationAngle, Survival::EMovementType Param_MovementType);
	void FinishedAcceleration(bool* Finished);
	void Get_Last_Point_Is_Target_Actor(bool* Param_LastPointIsTargetActor);
	void Get_Should_Skip_Calculations();
	void GetAngleBetweenDirections(double* Angle);
	double GetAnimationAngle();
	void GetCurrentPathPointLocation(struct FVector* Param_CurrentPathPointLocation);
	void GetDesiredVector(struct FVector* DesiredVector);
	double GetDistanceToNextPoint();
	double GetDistanceToStop();
	void GetIsMovingCorrectly(bool* bMovingCorrectly);
	bool GetIsStopping();
	E_AIMovementType GetMovementType();
	bool GetVelocityFromAnimation();
	double GetVelocityValue();
	void IncreasingMovement();
	void IncreasingMovementSetup();
	void InitializePath(bool Param_TargetIsActor, class AActor* Param_TargetActor, const struct FVector& TargetLocationIn, class AActor* Param_PathfindingContext, TSubclassOf<class UNavigationQueryFilter> Param_FilterClass);
	void Is_Current_Point_Not_Last(bool* IsNotLast);
	void IsCloseToTarget(bool* IsClose);
	void IsIndexInRange(int32 Param_Index, bool* InRange);
	void LastPointIsTarget(bool* IsTarget);
	void MovementTypeRepNotify();
	void MulticastRotationCurveNameRepNotify(Survival::EMovementType Param_MovementType, double Param_AnimationAngle);
	void On_Reach_Last_Point();
	void On_Set_Target_Actor(class AActor* Param_TargetActor);
	void OnReachPathPoint();
	void OnReachTarget__DelegateSignature();
	void OnRep_MovementType();
	void OnRep_PathMovementState();
	void OnRep_PathPoints();
	void OnRep_RotationCurveName();
	void PathMovementHandle();
	void ReachLastPoint();
	void ReceiveTick(float DeltaSeconds);
	void RefreshMovemenetType();
	void ResetAllVariables();
	void Rotation_Curve_Name_Rep_Notify(Survival::EMovementType Param_MovementType, double Param_AnimationAngle);
	void RotationExtraction(double DeltaSeconds);
	void RotationExtractionSubtick();
	void RotationSubtick(const struct FRotator& TargetRotation, float DeltaTime);
	void RotationTickExecutor();
	void Set_Owner_Rotation(double DeltaSeconds);
	void SetEndSpeedbyAngle(double Angle);
	void SetMovementSettings(const TMap<E_AIMovementType, struct FF_MovementSettings>& NewMovementSettings);
	void SetMovementSettingsCPP(const TMap<Survival::EMovementType, struct FF_MovementSettings>& NewMovementSettingsCPP);
	void SetMovementType(E_AIMovementType Param_MovementType, Survival::EMovementType NewParam);
	void SetOwnerRotationClient();
	void SetOwnerVelocity();
	void SetOwnerVelocityClient();
	void SetPathPoints(TArray<struct FVector>& InPoints);
	void SetStateAcceleration(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateAfterDecreaseAdjustment(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateChangePointDist(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateCloseDirInterpSpeed(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateCloseToTargetDist(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateDeceleration(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateDecreaseStateDist(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateHighestAngle(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateIncreaseStateDist(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateLowestAngle(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateMaxDirInterpSpeed(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateMaxSpeed(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateMinDirInterpSpeed(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateMinSpeed(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateSpeedInterpSpeed(E_AIMovementType Param_MovementType, double NewValue);
	void SetStateTwistCheckDistance(E_AIMovementType Param_MovementType, double NewValue);
	void StartMovement(bool StartFromAnimation);
	void StopAnimationMovement();
	bool StopCalculations();
	void StopExtractionRotationFromAnimation();
	void StopMovementImmediately_();
	void StopPathOnTooBigAngle(TArray<struct FVector>& PathPointsArr, TArray<struct FVector>* Param_PathPoints);
	void Time_To_Change_To_Decreasing_State(bool* Change);
	void Time_to_Change_to_Increasing_State(bool* Change);
	void TimeToChangePointIndex(bool* Change);
	bool TwistDetected();
	void UnblockZombie();
	void UnblockZombieFromWaterTarget();
	void UpdatePath();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"AIMovementComponent_C">();
	}
	static class UAIMovementComponent_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMovementComponent_C>();
	}
};
static_assert(alignof(UAIMovementComponent_C) == 0x000008, "Wrong alignment on UAIMovementComponent_C");
static_assert(sizeof(UAIMovementComponent_C) == 0x000578, "Wrong size on UAIMovementComponent_C");
static_assert(offsetof(UAIMovementComponent_C, UberGraphFrame) == 0x0000B0, "Member 'UAIMovementComponent_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CharMoveComp) == 0x0000B8, "Member 'UAIMovementComponent_C::CharMoveComp' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, IsStopping) == 0x0000C0, "Member 'UAIMovementComponent_C::IsStopping' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, ResultVelocity) == 0x0000C8, "Member 'UAIMovementComponent_C::ResultVelocity' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, VelocityDirection) == 0x0000E0, "Member 'UAIMovementComponent_C::VelocityDirection' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DesiredVelocityDirection) == 0x0000F8, "Member 'UAIMovementComponent_C::DesiredVelocityDirection' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, VelocityValue) == 0x000110, "Member 'UAIMovementComponent_C::VelocityValue' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MaxVelocityValue) == 0x000118, "Member 'UAIMovementComponent_C::MaxVelocityValue' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MinVelocityValue) == 0x000120, "Member 'UAIMovementComponent_C::MinVelocityValue' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DirectionInterpolationSpeed) == 0x000128, "Member 'UAIMovementComponent_C::DirectionInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, Path) == 0x000130, "Member 'UAIMovementComponent_C::Path' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, PathPoints) == 0x000138, "Member 'UAIMovementComponent_C::PathPoints' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TargetActor) == 0x000148, "Member 'UAIMovementComponent_C::TargetActor' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, PathfindingContext) == 0x000150, "Member 'UAIMovementComponent_C::PathfindingContext' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, FilterClass) == 0x000158, "Member 'UAIMovementComponent_C::FilterClass' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TargetIsActor) == 0x000160, "Member 'UAIMovementComponent_C::TargetIsActor' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, NextPathPointLocation) == 0x000168, "Member 'UAIMovementComponent_C::NextPathPointLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CurrentPathPointLocation) == 0x000180, "Member 'UAIMovementComponent_C::CurrentPathPointLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TargetPathGenerationLocation) == 0x000198, "Member 'UAIMovementComponent_C::TargetPathGenerationLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, PathPointLocation) == 0x0001B0, "Member 'UAIMovementComponent_C::PathPointLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TargetLocation) == 0x0001C8, "Member 'UAIMovementComponent_C::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CurrentPathPointIndex) == 0x0001E0, "Member 'UAIMovementComponent_C::CurrentPathPointIndex' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, EndMovementSpeed) == 0x0001E8, "Member 'UAIMovementComponent_C::EndMovementSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateAcceleration) == 0x0001F0, "Member 'UAIMovementComponent_C::StateAcceleration' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateDeceleration) == 0x0001F8, "Member 'UAIMovementComponent_C::StateDeceleration' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateMinSpeed) == 0x000200, "Member 'UAIMovementComponent_C::StateMinSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, VelocityFromAnimation) == 0x000208, "Member 'UAIMovementComponent_C::VelocityFromAnimation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DrawDebugLines) == 0x000209, "Member 'UAIMovementComponent_C::DrawDebugLines' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, OwnerLocation) == 0x000210, "Member 'UAIMovementComponent_C::OwnerLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, VelocityCurveName) == 0x000228, "Member 'UAIMovementComponent_C::VelocityCurveName' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, Character) == 0x000230, "Member 'UAIMovementComponent_C::Character' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CharacterAnimInstance) == 0x000238, "Member 'UAIMovementComponent_C::CharacterAnimInstance' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, AnimationAngle) == 0x000240, "Member 'UAIMovementComponent_C::AnimationAngle' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MovementType) == 0x000248, "Member 'UAIMovementComponent_C::MovementType' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationFromAnimation) == 0x000249, "Member 'UAIMovementComponent_C::RotationFromAnimation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationCurveName) == 0x00024C, "Member 'UAIMovementComponent_C::RotationCurveName' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StartRotationYawZ) == 0x000258, "Member 'UAIMovementComponent_C::StartRotationYawZ' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TurnTime) == 0x000260, "Member 'UAIMovementComponent_C::TurnTime' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationYawZ) == 0x000268, "Member 'UAIMovementComponent_C::RotationYawZ' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, AnimationRotationInterpolationSpeed) == 0x00026C, "Member 'UAIMovementComponent_C::AnimationRotationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, PathMovementState) == 0x000270, "Member 'UAIMovementComponent_C::PathMovementState' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateMaxSpeed) == 0x000278, "Member 'UAIMovementComponent_C::StateMaxSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateChangePointDist) == 0x000280, "Member 'UAIMovementComponent_C::StateChangePointDist' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DecreaseStateDist) == 0x000288, "Member 'UAIMovementComponent_C::DecreaseStateDist' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, IncreaseStateDist) == 0x000290, "Member 'UAIMovementComponent_C::IncreaseStateDist' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateDistanceToFilterPathPoints) == 0x000298, "Member 'UAIMovementComponent_C::StateDistanceToFilterPathPoints' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateHighestAngle) == 0x0002A0, "Member 'UAIMovementComponent_C::StateHighestAngle' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateLowestAngle) == 0x0002A8, "Member 'UAIMovementComponent_C::StateLowestAngle' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StartChangingVelocityValue) == 0x0002B0, "Member 'UAIMovementComponent_C::StartChangingVelocityValue' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, OnReachTarget) == 0x0002B8, "Member 'UAIMovementComponent_C::OnReachTarget' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DrawDebugPathPoints) == 0x0002C8, "Member 'UAIMovementComponent_C::DrawDebugPathPoints' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CharacterController) == 0x0002D0, "Member 'UAIMovementComponent_C::CharacterController' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, PathRegenerationDistance) == 0x0002D8, "Member 'UAIMovementComponent_C::PathRegenerationDistance' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateMinDirInterpSpeed) == 0x0002E0, "Member 'UAIMovementComponent_C::StateMinDirInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateMaxDirInterpSpeed) == 0x0002E8, "Member 'UAIMovementComponent_C::StateMaxDirInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateSpeedInterpSpeed) == 0x0002F0, "Member 'UAIMovementComponent_C::StateSpeedInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateIsCloseToTargetDistance) == 0x0002F8, "Member 'UAIMovementComponent_C::StateIsCloseToTargetDistance' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateCloseDirInterpSpeed) == 0x000300, "Member 'UAIMovementComponent_C::StateCloseDirInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateAfterDecreasingAdjustment) == 0x000308, "Member 'UAIMovementComponent_C::StateAfterDecreasingAdjustment' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, LastPointIsTargetActor) == 0x000310, "Member 'UAIMovementComponent_C::LastPointIsTargetActor' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MovementSettings) == 0x000318, "Member 'UAIMovementComponent_C::MovementSettings' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, StateTwistCheckDistance) == 0x000368, "Member 'UAIMovementComponent_C::StateTwistCheckDistance' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TargetActorLocation) == 0x000370, "Member 'UAIMovementComponent_C::TargetActorLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, EndPointMultiplier) == 0x000388, "Member 'UAIMovementComponent_C::EndPointMultiplier' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, NeedPreciseCalculation) == 0x000390, "Member 'UAIMovementComponent_C::NeedPreciseCalculation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DistanceToTarget) == 0x000398, "Member 'UAIMovementComponent_C::DistanceToTarget' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, TargetSpeedPrevious) == 0x0003A0, "Member 'UAIMovementComponent_C::TargetSpeedPrevious' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, ZombieInFront) == 0x0003A8, "Member 'UAIMovementComponent_C::ZombieInFront' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, Zombie) == 0x0003B0, "Member 'UAIMovementComponent_C::Zombie' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, ZombieCheckTimer) == 0x0003B8, "Member 'UAIMovementComponent_C::ZombieCheckTimer' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DistanceToZombie) == 0x0003C0, "Member 'UAIMovementComponent_C::DistanceToZombie' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, ActorsToIgnore) == 0x0003C8, "Member 'UAIMovementComponent_C::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MovementSettingsCPP) == 0x0003D8, "Member 'UAIMovementComponent_C::MovementSettingsCPP' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationCurves) == 0x000428, "Member 'UAIMovementComponent_C::RotationCurves' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CurrentRotationCurve) == 0x000478, "Member 'UAIMovementComponent_C::CurrentRotationCurve' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, EndTime) == 0x000480, "Member 'UAIMovementComponent_C::EndTime' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, DistanceToCurrentPathPoint) == 0x000488, "Member 'UAIMovementComponent_C::DistanceToCurrentPathPoint' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, bSkipCalculations) == 0x000490, "Member 'UAIMovementComponent_C::bSkipCalculations' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, PreviousDistance) == 0x000498, "Member 'UAIMovementComponent_C::PreviousDistance' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, bAlwaysRecalculateMovement) == 0x0004A0, "Member 'UAIMovementComponent_C::bAlwaysRecalculateMovement' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, SkipCalculationsDistance) == 0x0004A8, "Member 'UAIMovementComponent_C::SkipCalculationsDistance' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, bIsBlockedOnFront) == 0x0004B0, "Member 'UAIMovementComponent_C::bIsBlockedOnFront' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, ZombieBlockedBy) == 0x0004B8, "Member 'UAIMovementComponent_C::ZombieBlockedBy' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationExtractionSubtickTimer) == 0x0004C0, "Member 'UAIMovementComponent_C::RotationExtractionSubtickTimer' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationSubtickInterval) == 0x0004C8, "Member 'UAIMovementComponent_C::RotationSubtickInterval' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, NewRotation) == 0x0004D0, "Member 'UAIMovementComponent_C::NewRotation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, RotationSubtickTimer) == 0x0004E8, "Member 'UAIMovementComponent_C::RotationSubtickTimer' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, bUseRotationSubtick) == 0x0004F0, "Member 'UAIMovementComponent_C::bUseRotationSubtick' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MinDistanceBeforeLastPoint) == 0x0004F8, "Member 'UAIMovementComponent_C::MinDistanceBeforeLastPoint' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, UnblockZombieTimer) == 0x000500, "Member 'UAIMovementComponent_C::UnblockZombieTimer' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MinDistanceToStartMoving) == 0x000508, "Member 'UAIMovementComponent_C::MinDistanceToStartMoving' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, ReplicatedRotationZ) == 0x000510, "Member 'UAIMovementComponent_C::ReplicatedRotationZ' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MinAngleToStopMovement) == 0x000518, "Member 'UAIMovementComponent_C::MinAngleToStopMovement' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, MaxClientAngleDifference) == 0x000520, "Member 'UAIMovementComponent_C::MaxClientAngleDifference' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, UnblockZombieFromWaterTargetTimer) == 0x000528, "Member 'UAIMovementComponent_C::UnblockZombieFromWaterTargetTimer' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, VelocityLengthFromServer) == 0x000530, "Member 'UAIMovementComponent_C::VelocityLengthFromServer' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, bCarInFront) == 0x000538, "Member 'UAIMovementComponent_C::bCarInFront' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CarInFront) == 0x000540, "Member 'UAIMovementComponent_C::CarInFront' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CarHitLocation) == 0x000548, "Member 'UAIMovementComponent_C::CarHitLocation' has a wrong offset!");
static_assert(offsetof(UAIMovementComponent_C, CarHitReflectionVector) == 0x000560, "Member 'UAIMovementComponent_C::CarHitReflectionVector' has a wrong offset!");

}

